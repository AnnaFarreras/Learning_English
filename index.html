<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Joc verbs irregulars (anglÃ¨s)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .card { box-shadow: 0 10px 25px rgba(0,0,0,.08); }
    .btn-disabled { opacity:.55; pointer-events:none; }
    .shake { animation: shake .3s; }
    @keyframes shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-6px); }
      50% { transform: translateX(6px); }
      75% { transform: translateX(-6px); }
      100% { transform: translateX(0); }
    }

    /* Options: keep color even on hover */
    .optBtn { transition: background-color .15s, border-color .15s, transform .08s; }
    .optBtn:hover { background-color: rgb(241 245 249); } /* slate-100 */
    .optLocked:hover { background-color: inherit !important; }
    .optCorrect { background-color: rgb(134 239 172) !important; border-color: rgb(22 163 74) !important; }
    .optWrong { background-color: rgb(252 165 165) !important; border-color: rgb(220 38 38) !important; }
    .optReveal { background-color: rgb(134 239 172) !important; border-color: rgb(22 163 74) !important; }
  
      table{min-width:720px;}
      @media (max-width:480px){
        body{padding:12px !important;}
        h1{font-size:28px !important;}
        th,td{font-size:14px;}
      }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 min-h-screen p-3 sm:p-4">
  <div class="max-w-3xl mx-auto flex items-center justify-between mb-2 gap-2">
    <div class="flex items-center gap-2">
      <label for="audioModeSel" class="text-xs text-slate-500 whitespace-nowrap">Ã€udio</label>
      <select id="audioModeSel" class="border rounded-lg px-2 py-2 bg-white text-sm">
        <option value="manual">Manual</option>
        <option value="auto">AutomÃ tic</option>
      </select>
    </div>
    <select id="langSel" class="border rounded-lg px-3 py-2 bg-white text-sm">
      <option value="ca">CatalÃ </option>
      <option value="es">Castellano</option>
      <option value="ka">áƒ¥áƒáƒ áƒ—áƒ£áƒšáƒ˜</option>
    </select>
  </div>

  <div id="app" class="max-w-3xl mx-auto bg-white rounded-2xl card p-4 sm:p-6">
    <header class="mb-3">
      <h1 id="appTitle" class="text-xl sm:text-2xl font-bold text-center">Joc de verbs irregulars (anglÃ¨s)</h1>
      <p id="appSubtitle" class="text-center text-slate-500 mt-1 text-sm">
        6 nivells. No pots pujar de nivell fins que hagis encertat <b>tots</b> els verbs almenys 1 cop.
      </p>
    </header>

    <div class="mb-3">
      <div class="flex items-start justify-between gap-2">
        <div id="levelBar" class="flex flex-wrap gap-2 justify-center w-full">
          <button data-level="1" class="levelBtn shrink-0 bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 transition text-sm">N1</button>
          <button data-level="2" class="levelBtn shrink-0 bg-sky-500 text-white px-3 py-1 rounded hover:bg-sky-600 transition text-sm">N2</button>
          <button data-level="3" class="levelBtn shrink-0 bg-teal-500 text-white px-3 py-1 rounded hover:bg-teal-600 transition text-sm">N3</button>
          <button data-level="4" class="levelBtn shrink-0 bg-emerald-500 text-white px-3 py-1 rounded hover:bg-emerald-600 transition text-sm">N4</button>
          <button data-level="5" class="levelBtn shrink-0 bg-amber-500 text-white px-3 py-1 rounded hover:bg-amber-600 transition text-sm">N5</button>
          <button data-level="6" class="levelBtn shrink-0 bg-purple-600 text-white px-3 py-1 rounded hover:bg-purple-700 transition text-sm">N6</button>
</div>

        <div class="flex flex-col gap-2 items-end">
          <button id="btnHelp" class="bg-slate-200 text-slate-800 font-bold px-2 py-1 rounded hover:bg-slate-300 transition text-xs w-[110px] text-center">Com funciona</button>
          <button id="btnReset" class="bg-red-600 text-white font-bold px-2 py-1 rounded hover:bg-red-700 transition text-xs w-[110px] text-center">Reinicia progrÃ©s</button>
          <button id="btnList" class="bg-emerald-600 text-white font-bold px-2 py-1 rounded hover:bg-emerald-700 transition text-xs w-[110px] text-center">Llista de verbs</button>
        <div class="h-2"></div>
        <label class="inline-flex items-center gap-2 text-sm text-slate-700 select-none cursor-pointer">
          <input id="chkOnlyMarked" type="checkbox" class="w-4 h-4">
          <span id="lblOnlyMarked">NomÃ©s marcats</span>
        </label>
        </div>
      </div>

      <div id="devHint" class="mt-2 hidden text-xs text-slate-500">
        Mode prova actiu: nivells desbloquejats (URL amb <code class="bg-slate-100 px-1 rounded">?dev=1</code>).
      </div>
    </div>

    <div class="mb-4">
      <div class="flex justify-between text-sm text-slate-600 mb-1">
        <span id="lblProgress">ProgrÃ©s del nivell</span>
        <span id="progressPct">0%</span>
      </div>
      <div class="w-full bg-slate-200 rounded-full h-3 overflow-hidden">
        <div id="progressBar" class="h-3 bg-blue-500" style="width:0%"></div>
      </div>
      <div class="mt-2 text-sm text-slate-600 flex flex-wrap gap-x-4 gap-y-1 justify-between">
        <div id="scoreLine">Encerts: 0 Â· Errors: 0</div>
        <div id="masterLine">Dominats aquest nivell: 0 / 0</div>
      </div>
    </div>

    <div id="quizArea" class="bg-slate-50 rounded-xl p-4 sm:p-6">
      <div>
        <div class="text-sm text-slate-500" id="levelTitle">Nivell 1</div>
        <div class="mt-1 flex items-center justify-center gap-2">
          <div class="text-xl sm:text-2xl font-semibold" id="questionText">Selecciona un nivell per comenÃ§ar</div>
          <button id="btnSpeak" title="Escoltar pronunciaciÃ³" class="hidden bg-slate-200 hover:bg-slate-300 rounded px-2 py-1 text-sm">ğŸ”Š</button>
        </div>
        <div class="text-sm text-slate-500 mt-2" id="questionHint"></div>
      </div>

      <div id="answers" class="mt-5 grid grid-cols-1 sm:grid-cols-3 gap-2"></div>


      <!-- Nivell 3: escriu el verb (lletres) -->
      <div id="level3Letters" class="mt-3 hidden">
        <div class="bg-white rounded-xl border p-3">
          <div class="flex items-center justify-between mb-2">
            <div class="text-xs text-slate-500">Completa el verb en anglÃ¨s</div>
            <div class="flex items-center gap-2">
              <button id="btnL3Help" class="w-9 h-9 rounded-lg border bg-white hover:bg-slate-50 text-slate-700 font-bold" title="Ajuda">?</button>
              <button id="btnL3Speak" class="w-9 h-9 rounded-lg border bg-white hover:bg-slate-50 text-slate-700" title="Pronuncia (anglÃ¨s)" disabled>ğŸ”Š</button>
            </div>
          </div>
          <div id="letterSlots" class="flex flex-wrap gap-2 justify-center"></div>
          <div class="mt-2 text-sm text-slate-500 text-center"><span id="lblLetterExplain">Clica les lletres correctes. Si Ã©s correcta, es posarÃ  automÃ ticament al seu lloc. Les incorrectes es marcaran amb una <span class="text-red-600 font-black">âœ–</span>.</span></div>
        </div>
        <div class="mt-2 bg-white rounded-xl border p-3">
          <div class="text-xs text-slate-500 mb-2">Lletres disponibles</div>
          <div id="letterBank" class="flex flex-wrap gap-2 justify-center"></div>
        </div>
      </div>
      <div id="level6Area" class="mt-3 hidden">
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
          <div class="bg-white rounded-lg p-2 border">
            <div class="text-xs text-slate-500 mb-1">Infinitive</div>
            <select id="selInf" class="w-full border rounded-lg p-2 bg-white"></select>
          </div>
          <div class="bg-white rounded-lg p-2 border">
            <div class="text-xs text-slate-500 mb-1">Simple past</div>
            <select id="selPast" class="w-full border rounded-lg p-2 bg-white"></select>
          </div>
          <div class="bg-white rounded-lg p-2 border">
            <div class="text-xs text-slate-500 mb-1">Past participle</div>
            <select id="selPP" class="w-full border rounded-lg p-2 bg-white"></select>
          </div>
        </div>
        <button id="btnCheckLevel6" class="mt-2 w-full bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition">
          Comprovar
        </button>
      </div>

      <div class="mt-5">
        <div id="feedback" class="text-base font-bold text-center sm:text-left"></div>
      </div>

      <div class="mt-3 flex items-center justify-between gap-3">
        <div class="text-sm text-slate-500">
          <span id="lblQuestion">Pregunta:</span> <span class="font-semibold text-slate-700" id="qIndex">â€”</span> / <span class="font-semibold text-slate-700" id="qTotal">â€”</span>
        </div>
        <button id="btnNext" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition">
          SegÃ¼ent
        </button>
      </div>
    </div>

    <div id="modal" class="fixed inset-0 bg-black/40 hidden items-center justify-center p-4 z-50">
      <div class="bg-white rounded-2xl p-5 max-w-lg w-full">
        <div class="flex justify-between items-center gap-3">
          <h2 id="modalTitle" class="text-xl font-bold"></h2>
          <button id="modalClose" class="text-slate-500 hover:text-slate-800 text-2xl leading-none">&times;</button>
        </div>
        <div id="modalBody" class="mt-3 text-slate-700 text-sm"></div>
        <div class="mt-5 flex justify-end gap-2">
          <button id="modalOk" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition">D'acord</button>
        </div>
      </div>
    </div>
  </div>

<script>
const DEFAULT_VERBS = [{"inf": "arise", "past_raw": "arose", "pp_raw": "arisen", "past": "arose", "pp": "arisen", "es": "surgir", "ca": "sorgir", "ka": "áƒ¬áƒáƒ áƒ›áƒáƒ¨áƒáƒ‘áƒ / áƒáƒ¦áƒ›áƒáƒªáƒ”áƒœáƒ”áƒ‘áƒ"}, {"inf": "be", "past_raw": "was / were", "pp_raw": "been", "past": "was", "pp": "been", "es": "ser/estar", "ca": "ser/estar", "ka": "áƒ§áƒáƒ¤áƒœáƒ"}, {"inf": "beat", "past_raw": "beat", "pp_raw": "beaten", "past": "beat", "pp": "beaten", "es": "golpear / vencer", "ca": "colpejar / vÃ¨ncer", "ka": "áƒªáƒ”áƒ›áƒ / áƒ“áƒáƒ áƒ¢áƒ§áƒ›áƒ"}, {"inf": "become", "past_raw": "became", "pp_raw": "become", "past": "became", "pp": "become", "es": "convertirse en", "ca": "esdevenir / convertir-se en", "ka": "áƒ’áƒáƒ®áƒ“áƒáƒ›áƒ"}, {"inf": "begin", "past_raw": "began", "pp_raw": "begun", "past": "began", "pp": "begun", "es": "empezar", "ca": "comenÃ§ar", "ka": "áƒ“áƒáƒ¬áƒ§áƒ”áƒ‘áƒ"}, {"inf": "bet", "past_raw": "bet/betted", "pp_raw": "bet/betted", "past": "bet", "pp": "bet", "es": "apostar", "ca": "apostar", "ka": "áƒ“áƒáƒœáƒáƒ«áƒšáƒ”áƒ•áƒ”áƒ‘áƒ"}, {"inf": "bite", "past_raw": "bit", "pp_raw": "bitten", "past": "bit", "pp": "bitten", "es": "morder", "ca": "mossegar", "ka": "áƒ™áƒ‘áƒ”áƒœáƒ"}, {"inf": "bleed", "past_raw": "bled", "pp_raw": "bled", "past": "bled", "pp": "bled", "es": "sangrar", "ca": "sagnar", "ka": "áƒ¡áƒ˜áƒ¡áƒ®áƒšáƒ“áƒ”áƒœáƒ"}, {"inf": "blow", "past_raw": "blew", "pp_raw": "blown", "past": "blew", "pp": "blown", "es": "soplar", "ca": "bufar", "ka": "áƒ“áƒáƒ‘áƒ”áƒ áƒ•áƒ"}, {"inf": "break", "past_raw": "broke", "pp_raw": "broken", "past": "broke", "pp": "broken", "es": "romper", "ca": "trencar", "ka": "áƒ’áƒáƒ¢áƒ”áƒ®áƒ•áƒ"}, {"inf": "bring", "past_raw": "brought", "pp_raw": "brought", "past": "brought", "pp": "brought", "es": "traer", "ca": "portar", "ka": "áƒ›áƒáƒ¢áƒáƒœáƒ"}, {"inf": "build", "past_raw": "built", "pp_raw": "built", "past": "built", "pp": "built", "es": "construir", "ca": "construir", "ka": "áƒáƒ¨áƒ”áƒœáƒ”áƒ‘áƒ"}, {"inf": "buy", "past_raw": "bought", "pp_raw": "bought", "past": "bought", "pp": "bought", "es": "comprar", "ca": "comprar", "ka": "áƒ§áƒ˜áƒ“áƒ•áƒ"}, {"inf": "catch", "past_raw": "caught", "pp_raw": "caught", "past": "caught", "pp": "caught", "es": "atrapar", "ca": "atrapar / agafar", "ka": "áƒ“áƒáƒ­áƒ”áƒ áƒ"}, {"inf": "choose", "past_raw": "chose", "pp_raw": "chosen", "past": "chose", "pp": "chosen", "es": "elegir", "ca": "triar / escollir", "ka": "áƒáƒ áƒ©áƒ”áƒ•áƒ"}, {"inf": "come", "past_raw": "came", "pp_raw": "come", "past": "came", "pp": "come", "es": "venir", "ca": "venir", "ka": "áƒ›áƒáƒ¡áƒ•áƒšáƒ"}, {"inf": "cost", "past_raw": "cost", "pp_raw": "cost", "past": "cost", "pp": "cost", "es": "costar", "ca": "costar", "ka": "áƒ¦áƒ˜áƒ áƒ”áƒ‘áƒ"}, {"inf": "creep", "past_raw": "crept", "pp_raw": "crept", "past": "crept", "pp": "crept", "es": "arrastrarse", "ca": "arrossegar-se", "ka": "áƒªáƒáƒªáƒ•áƒ"}, {"inf": "cut", "past_raw": "cut", "pp_raw": "cut", "past": "cut", "pp": "cut", "es": "cortar", "ca": "tallar", "ka": "áƒ­áƒ áƒ"}, {"inf": "deal", "past_raw": "dealt", "pp_raw": "dealt", "past": "dealt", "pp": "dealt", "es": "tratar (con) / repartir", "ca": "tractar (amb) / repartir", "ka": "áƒ’áƒáƒ áƒ˜áƒ’áƒ”áƒ‘áƒ / áƒ•áƒáƒ­áƒ áƒáƒ‘áƒ"}, {"inf": "do", "past_raw": "did", "pp_raw": "done", "past": "did", "pp": "done", "es": "hacer", "ca": "fer", "ka": "áƒ™áƒ”áƒ—áƒ”áƒ‘áƒ"}, {"inf": "draw", "past_raw": "drew", "pp_raw": "drawn", "past": "drew", "pp": "drawn", "es": "dibujar", "ca": "dibuixar", "ka": "áƒ®áƒáƒ¢áƒ•áƒ / áƒ®áƒáƒ–áƒ•áƒ"}, {"inf": "dream", "past_raw": "dreamt/dreamed", "pp_raw": "dreamt/dreamed", "past": "dreamt", "pp": "dreamt", "es": "soÃ±ar", "ca": "somiar", "ka": "áƒáƒªáƒœáƒ”áƒ‘áƒ"}, {"inf": "drink", "past_raw": "drank", "pp_raw": "drunk", "past": "drank", "pp": "drunk", "es": "beber", "ca": "beure", "ka": "áƒ“áƒáƒšáƒ”áƒ•áƒ"}, {"inf": "drive", "past_raw": "drove", "pp_raw": "driven", "past": "drove", "pp": "driven", "es": "conducir", "ca": "conduir", "ka": "áƒ›áƒáƒ áƒ—áƒ•áƒ"}, {"inf": "eat", "past_raw": "ate", "pp_raw": "eaten", "past": "ate", "pp": "eaten", "es": "comer", "ca": "menjar", "ka": "áƒ­áƒáƒ›áƒ"}, {"inf": "fall", "past_raw": "fell", "pp_raw": "fallen", "past": "fell", "pp": "fallen", "es": "caer", "ca": "caure", "ka": "áƒ“áƒáƒªáƒ”áƒ›áƒ"}, {"inf": "feed", "past_raw": "fed", "pp_raw": "fed", "past": "fed", "pp": "fed", "es": "alimentar", "ca": "alimentar", "ka": "áƒ™áƒ•áƒ”áƒ‘áƒ"}, {"inf": "feel", "past_raw": "felt", "pp_raw": "felt", "past": "felt", "pp": "felt", "es": "sentir", "ca": "sentir", "ka": "áƒ’áƒ áƒ«áƒœáƒáƒ‘áƒ"}, {"inf": "fight", "past_raw": "fought", "pp_raw": "fought", "past": "fought", "pp": "fought", "es": "luchar", "ca": "lluitar", "ka": "áƒ‘áƒ áƒ«áƒáƒšáƒ"}, {"inf": "find", "past_raw": "found", "pp_raw": "found", "past": "found", "pp": "found", "es": "encontrar", "ca": "trobar", "ka": "áƒáƒáƒ•áƒœáƒ"}, {"inf": "flee", "past_raw": "fled", "pp_raw": "fled", "past": "fled", "pp": "fled", "es": "huir", "ca": "fugir", "ka": "áƒ’áƒáƒ¥áƒªáƒ”áƒ•áƒ"}, {"inf": "fly", "past_raw": "flew", "pp_raw": "flown", "past": "flew", "pp": "flown", "es": "volar", "ca": "volar", "ka": "áƒ¤áƒ áƒ”áƒœáƒ"}, {"inf": "forget", "past_raw": "forgot", "pp_raw": "forgotten", "past": "forgot", "pp": "forgotten", "es": "olvidar", "ca": "oblidar", "ka": "áƒ“áƒáƒ•áƒ˜áƒ¬áƒ§áƒ”áƒ‘áƒ"}, {"inf": "forgive", "past_raw": "forgave", "pp_raw": "forgiven", "past": "forgave", "pp": "forgiven", "es": "perdonar", "ca": "perdonar", "ka": "áƒ›áƒ˜áƒ¢áƒ”áƒ•áƒ”áƒ‘áƒ"}, {"inf": "forsake", "past_raw": "forsook", "pp_raw": "forsaken", "past": "forsook", "pp": "forsaken", "es": "abandonar", "ca": "abandonar", "ka": "áƒ›áƒ˜áƒ¢áƒáƒ•áƒ”áƒ‘áƒ"}, {"inf": "freeze", "past_raw": "froze", "pp_raw": "frozen", "past": "froze", "pp": "frozen", "es": "congelar(se)", "ca": "congelar(-se)", "ka": "áƒ’áƒáƒ§áƒ˜áƒœáƒ•áƒ"}, {"inf": "get", "past_raw": "got", "pp_raw": "got", "past": "got", "pp": "got", "es": "conseguir / obtener", "ca": "aconseguir / obtenir", "ka": "áƒ›áƒ˜áƒ¦áƒ”áƒ‘áƒ"}, {"inf": "give", "past_raw": "gave", "pp_raw": "given", "past": "gave", "pp": "given", "es": "dar", "ca": "donar", "ka": "áƒ›áƒ˜áƒªáƒ”áƒ›áƒ"}, {"inf": "go", "past_raw": "went", "pp_raw": "gone", "past": "went", "pp": "gone", "es": "ir", "ca": "anar", "ka": "áƒ¬áƒáƒ¡áƒ•áƒšáƒ"}, {"inf": "grind", "past_raw": "ground", "pp_raw": "ground", "past": "ground", "pp": "ground", "es": "moler / triturar", "ca": "moldre / triturar", "ka": "áƒ“áƒáƒ¤áƒ¥áƒ•áƒ"}, {"inf": "grow", "past_raw": "grew", "pp_raw": "grown", "past": "grew", "pp": "grown", "es": "crecer", "ca": "crÃ©ixer", "ka": "áƒ’áƒáƒ–áƒ áƒ“áƒ"}, {"inf": "hang", "past_raw": "hung", "pp_raw": "hung", "past": "hung", "pp": "hung", "es": "colgar", "ca": "penjar", "ka": "áƒ“áƒáƒ™áƒ˜áƒ“áƒ”áƒ‘áƒ"}, {"inf": "have", "past_raw": "had", "pp_raw": "had", "past": "had", "pp": "had", "es": "tener", "ca": "tenir", "ka": "áƒ¥áƒáƒœáƒ"}, {"inf": "hear", "past_raw": "heard", "pp_raw": "heard", "past": "heard", "pp": "heard", "es": "oÃ­r", "ca": "sentir (oÃ¯da)", "ka": "áƒ¡áƒ›áƒ”áƒœáƒ"}, {"inf": "hide", "past_raw": "hid", "pp_raw": "hidden", "past": "hid", "pp": "hidden", "es": "esconder", "ca": "amagar", "ka": "áƒ“áƒáƒ›áƒáƒšáƒ•áƒ"}, {"inf": "hit", "past_raw": "hit", "pp_raw": "hit", "past": "hit", "pp": "hit", "es": "golpear", "ca": "colpejar", "ka": "áƒ“áƒáƒ áƒ¢áƒ§áƒ›áƒ"}, {"inf": "hold", "past_raw": "held", "pp_raw": "held", "past": "held", "pp": "held", "es": "sostener / aguantar", "ca": "aguantar / sostenir", "ka": "áƒ“áƒáƒ­áƒ”áƒ áƒ / áƒ“áƒáƒ­áƒ”áƒ áƒ-áƒ¨áƒ”áƒœáƒáƒ áƒ©áƒ£áƒœáƒ”áƒ‘áƒ"}, {"inf": "hurt", "past_raw": "hurt", "pp_raw": "hurt", "past": "hurt", "pp": "hurt", "es": "herir / doler", "ca": "ferir / fer mal", "ka": "áƒ¢áƒ™áƒ”áƒœáƒ / áƒ“áƒáƒ–áƒ˜áƒáƒœáƒ”áƒ‘áƒ"}, {"inf": "keep", "past_raw": "kept", "pp_raw": "kept", "past": "kept", "pp": "kept", "es": "mantener / guardar", "ca": "mantenir / guardar", "ka": "áƒ¨áƒ”áƒœáƒáƒ áƒ©áƒ£áƒœáƒ”áƒ‘áƒ / áƒ¨áƒ”áƒœáƒáƒ®áƒ•áƒ"}, {"inf": "kneel", "past_raw": "knelt", "pp_raw": "knelt", "past": "knelt", "pp": "knelt", "es": "arrodillarse", "ca": "agenollar-se", "ka": "áƒ“áƒáƒ©áƒáƒ¥áƒ”áƒ‘áƒ"}, {"inf": "know", "past_raw": "knew", "pp_raw": "known", "past": "knew", "pp": "known", "es": "saber / conocer", "ca": "saber / conÃ¨ixer", "ka": "áƒªáƒáƒ“áƒœáƒ / áƒ’áƒáƒªáƒœáƒáƒ‘áƒ"}, {"inf": "lead", "past_raw": "led", "pp_raw": "led", "past": "led", "pp": "led", "es": "liderar / guiar", "ca": "liderar / guiar", "ka": "áƒ¬áƒáƒ§áƒ•áƒáƒœáƒ / áƒ®áƒ”áƒšáƒ›áƒ«áƒ¦áƒ•áƒáƒœáƒ”áƒšáƒáƒ‘áƒ"}, {"inf": "learn", "past_raw": "learnt/learned", "pp_raw": "learnt/learned", "past": "learnt", "pp": "learnt", "es": "aprender", "ca": "aprendre", "ka": "áƒ¡áƒ¬áƒáƒ•áƒšáƒ"}, {"inf": "leave", "past_raw": "left", "pp_raw": "left", "past": "left", "pp": "left", "es": "dejar / irse", "ca": "deixar / marxar", "ka": "áƒ“áƒáƒ¢áƒáƒ•áƒ”áƒ‘áƒ"}, {"inf": "lend", "past_raw": "lent", "pp_raw": "lent", "past": "lent", "pp": "lent", "es": "prestar", "ca": "prestar", "ka": "áƒ¡áƒ”áƒ¡áƒ®áƒ”áƒ‘áƒ"}, {"inf": "let", "past_raw": "let", "pp_raw": "let", "past": "let", "pp": "let", "es": "dejar / permitir", "ca": "deixar / permetre", "ka": "áƒ“áƒáƒ¨áƒ•áƒ”áƒ‘áƒ / áƒœáƒ”áƒ‘áƒ áƒ“áƒáƒ áƒ—áƒ•áƒ"}, {"inf": "lie", "past_raw": "lay", "pp_raw": "lain", "past": "lay", "pp": "lain", "es": "tumbarse / yacer", "ca": "jeure / estirar-se", "ka": "áƒ¬áƒáƒšáƒ"}, {"inf": "lose", "past_raw": "lost", "pp_raw": "lost", "past": "lost", "pp": "lost", "es": "perder", "ca": "perdre", "ka": "áƒ“áƒáƒ™áƒáƒ áƒ’áƒ•áƒ"}, {"inf": "make", "past_raw": "made", "pp_raw": "made", "past": "made", "pp": "made", "es": "hacer / fabricar", "ca": "fer / fabricar", "ka": "áƒ’áƒáƒ™áƒ”áƒ—áƒ”áƒ‘áƒ / áƒ¨áƒ”áƒ¥áƒ›áƒœáƒ"}, {"inf": "mean", "past_raw": "meant", "pp_raw": "meant", "past": "meant", "pp": "meant", "es": "significar", "ca": "significar / voler dir", "ka": "áƒœáƒ˜áƒ¨áƒœáƒáƒ•áƒ“áƒ”áƒ¡"}, {"inf": "meet", "past_raw": "met", "pp_raw": "met", "past": "met", "pp": "met", "es": "conocer / encontrarse", "ca": "conÃ¨ixer / trobar-se", "ka": "áƒ¨áƒ”áƒ®áƒ•áƒ”áƒ“áƒ áƒ / áƒ’áƒáƒªáƒœáƒáƒ‘áƒ"}, {"inf": "pay", "past_raw": "paid", "pp_raw": "paid", "past": "paid", "pp": "paid", "es": "pagar", "ca": "pagar", "ka": "áƒ’áƒáƒ“áƒáƒ®áƒ“áƒ"}, {"inf": "put", "past_raw": "put", "pp_raw": "put", "past": "put", "pp": "put", "es": "poner", "ca": "posar", "ka": "áƒ“áƒáƒ“áƒ”áƒ‘áƒ / áƒ©áƒáƒ“áƒ”áƒ‘áƒ"}, {"inf": "quit", "past_raw": "quit/quitted", "pp_raw": "quit/quitted", "past": "quit", "pp": "quit", "es": "dejar / abandonar", "ca": "deixar / abandonar", "ka": "áƒ¨áƒ”áƒ¬áƒ§áƒ•áƒ”áƒ¢áƒ / áƒ›áƒ˜áƒ¢áƒáƒ•áƒ”áƒ‘áƒ"}, {"inf": "read", "past_raw": "read", "pp_raw": "read", "past": "read", "pp": "read", "es": "leer", "ca": "llegir", "ka": "áƒ™áƒ˜áƒ—áƒ®áƒ•áƒ"}, {"inf": "ride", "past_raw": "rode", "pp_raw": "ridden", "past": "rode", "pp": "ridden", "es": "montar (en bici/caballo)", "ca": "muntar (en bici/cavall)", "ka": "áƒ¢áƒáƒ áƒ”áƒ‘áƒ / áƒªáƒ®áƒ”áƒœáƒáƒ¡áƒœáƒáƒ‘áƒ"}, {"inf": "ring", "past_raw": "rang", "pp_raw": "rung", "past": "rang", "pp": "rung", "es": "sonar / llamar", "ca": "sonar / trucar", "ka": "áƒ“áƒáƒ áƒ”áƒ™áƒ•áƒ"}, {"inf": "rise", "past_raw": "rose", "pp_raw": "risen", "past": "rose", "pp": "risen", "es": "levantarse / subir", "ca": "aixecar-se / pujar", "ka": "áƒáƒ›áƒáƒ¦áƒšáƒ”áƒ‘áƒ / áƒáƒ¬áƒ”áƒ•áƒ"}, {"inf": "run", "past_raw": "ran", "pp_raw": "run", "past": "ran", "pp": "run", "es": "correr", "ca": "cÃ³rrer", "ka": "áƒ¡áƒ˜áƒ áƒ‘áƒ˜áƒšáƒ˜"}, {"inf": "say", "past_raw": "said", "pp_raw": "said", "past": "said", "pp": "said", "es": "decir", "ca": "dir", "ka": "áƒ—áƒ¥áƒ›áƒ"}, {"inf": "see", "past_raw": "saw", "pp_raw": "seen", "past": "saw", "pp": "seen", "es": "ver", "ca": "veure", "ka": "áƒœáƒáƒ®áƒ•áƒ"}, {"inf": "sell", "past_raw": "sold", "pp_raw": "sold", "past": "sold", "pp": "sold", "es": "vender", "ca": "vendre", "ka": "áƒ’áƒáƒ§áƒ˜áƒ“áƒ•áƒ"}, {"inf": "send", "past_raw": "sent", "pp_raw": "sent", "past": "sent", "pp": "sent", "es": "enviar", "ca": "enviar", "ka": "áƒ’áƒáƒ’áƒ–áƒáƒ•áƒœáƒ"}, {"inf": "set", "past_raw": "set", "pp_raw": "set", "past": "set", "pp": "set", "es": "poner / establecer", "ca": "posar / establir", "ka": "áƒ“áƒáƒ§áƒ”áƒœáƒ”áƒ‘áƒ / áƒ“áƒáƒ§áƒ”áƒœáƒ”áƒ‘áƒ-áƒ©áƒáƒ§áƒ”áƒœáƒ”áƒ‘áƒ"}, {"inf": "sew", "past_raw": "sewed", "pp_raw": "sewn/sewed", "past": "sewed", "pp": "sewn", "es": "coser", "ca": "cosir", "ka": "áƒ™áƒ”áƒ áƒ•áƒ"}, {"inf": "shake", "past_raw": "shook", "pp_raw": "shaken", "past": "shook", "pp": "shaken", "es": "sacudir", "ca": "sacsejar", "ka": "áƒ¨áƒ”áƒ áƒ§áƒ”áƒ•áƒ"}, {"inf": "shine", "past_raw": "shone", "pp_raw": "shone", "past": "shone", "pp": "shone", "es": "brillar", "ca": "brillar", "ka": "áƒ‘áƒ áƒ¬áƒ§áƒ˜áƒœáƒ•áƒ"}, {"inf": "shoot", "past_raw": "shot", "pp_raw": "shot", "past": "shot", "pp": "shot", "es": "disparar", "ca": "disparar", "ka": "áƒ¡áƒ áƒáƒšáƒ"}, {"inf": "show", "past_raw": "showed", "pp_raw": "shown/showed", "past": "showed", "pp": "shown", "es": "mostrar", "ca": "mostrar", "ka": "áƒ©áƒ•áƒ”áƒœáƒ”áƒ‘áƒ"}, {"inf": "shrink", "past_raw": "shrank/shrunk", "pp_raw": "shrunk", "past": "shrank", "pp": "shrunk", "es": "encoger", "ca": "encongir-se", "ka": "áƒ¨áƒ”áƒ™áƒ£áƒ›áƒ¨áƒ•áƒ / áƒ“áƒáƒáƒáƒ¢áƒáƒ áƒáƒ•áƒ”áƒ‘áƒ"}, {"inf": "shut", "past_raw": "shut", "pp_raw": "shut", "past": "shut", "pp": "shut", "es": "cerrar", "ca": "tancar", "ka": "áƒ“áƒáƒ®áƒ£áƒ áƒ•áƒ"}, {"inf": "sing", "past_raw": "sang", "pp_raw": "sung", "past": "sang", "pp": "sung", "es": "cantar", "ca": "cantar", "ka": "áƒ¡áƒ˜áƒ›áƒ¦áƒ”áƒ áƒ"}, {"inf": "sink", "past_raw": "sank", "pp_raw": "sunk", "past": "sank", "pp": "sunk", "es": "hundirse", "ca": "enfonsar-se", "ka": "áƒ©áƒáƒ«áƒ˜áƒ áƒ•áƒ"}, {"inf": "sit", "past_raw": "sat", "pp_raw": "sat", "past": "sat", "pp": "sat", "es": "sentarse", "ca": "seure", "ka": "áƒ¯áƒ“áƒáƒ›áƒ"}, {"inf": "sleep", "past_raw": "slept", "pp_raw": "slept", "past": "slept", "pp": "slept", "es": "dormir", "ca": "dormir", "ka": "áƒ«áƒ˜áƒšáƒ˜"}, {"inf": "slide", "past_raw": "slid", "pp_raw": "slid", "past": "slid", "pp": "slid", "es": "deslizar(se)", "ca": "lliscar", "ka": "áƒ¡áƒ áƒ˜áƒáƒšáƒ˜"}, {"inf": "sow", "past_raw": "sowed", "pp_raw": "sown/sowed", "past": "sowed", "pp": "sown", "es": "sembrar", "ca": "sembrar", "ka": "áƒ—áƒ”áƒ¡áƒ•áƒ"}, {"inf": "speak", "past_raw": "spoke", "pp_raw": "spoken", "past": "spoke", "pp": "spoken", "es": "hablar", "ca": "parlar", "ka": "áƒšáƒáƒáƒáƒ áƒáƒ™áƒ˜"}, {"inf": "spell", "past_raw": "spelt/spelled", "pp_raw": "spelt/spelled", "past": "spelt", "pp": "spelt", "es": "deletrear", "ca": "lletrejar", "ka": "áƒ›áƒáƒ áƒªáƒ•áƒšáƒ”áƒ‘áƒ˜áƒ— áƒ“áƒáƒ¬áƒ”áƒ áƒ"}, {"inf": "spend", "past_raw": "spent", "pp_raw": "spent", "past": "spent", "pp": "spent", "es": "gastar / pasar (tiempo)", "ca": "gastar / passar (temps)", "ka": "áƒ“áƒáƒ®áƒáƒ áƒ¯áƒ•áƒ"}, {"inf": "spill", "past_raw": "spilt/spilled", "pp_raw": "spilt/spilled", "past": "spilt", "pp": "spilt", "es": "derramar", "ca": "vessar", "ka": "áƒ“áƒáƒ¦áƒ•áƒ áƒ"}, {"inf": "split", "past_raw": "split", "pp_raw": "split", "past": "split", "pp": "split", "es": "dividir / partir", "ca": "dividir / partir", "ka": "áƒ’áƒáƒ§áƒáƒ¤áƒ"}, {"inf": "spoil", "past_raw": "spoilt/spoiled", "pp_raw": "spoilt/spoiled", "past": "spoilt", "pp": "spoilt", "es": "estropear", "ca": "espatllar", "ka": "áƒ’áƒáƒ¤áƒ£áƒ­áƒ”áƒ‘áƒ"}, {"inf": "spread", "past_raw": "spread", "pp_raw": "spread", "past": "spread", "pp": "spread", "es": "extender / difundir", "ca": "estendre / escampar", "ka": "áƒ’áƒáƒ•áƒ áƒªáƒ”áƒšáƒ”áƒ‘áƒ"}, {"inf": "stand", "past_raw": "stood", "pp_raw": "stood", "past": "stood", "pp": "stood", "es": "estar de pie", "ca": "estar dret", "ka": "áƒ“áƒ’áƒáƒ›áƒ"}, {"inf": "steal", "past_raw": "stole", "pp_raw": "stolen", "past": "stole", "pp": "stolen", "es": "robar", "ca": "robar", "ka": "áƒ¥áƒ£áƒ áƒ“áƒáƒ‘áƒ"}, {"inf": "sting", "past_raw": "stung", "pp_raw": "stung", "past": "stung", "pp": "stung", "es": "picar", "ca": "picar", "ka": "áƒ“áƒáƒ™áƒ‘áƒ”áƒœáƒ / áƒœáƒ”áƒ¡áƒ¢áƒ áƒ˜áƒ— áƒ©áƒ®áƒ•áƒšáƒ”áƒ¢áƒ"}, {"inf": "stink", "past_raw": "stank/stunk", "pp_raw": "stunk", "past": "stank", "pp": "stunk", "es": "apestar / oler mal", "ca": "fer pudor", "ka": "áƒ§áƒ áƒáƒšáƒ"}, {"inf": "strike", "past_raw": "struck", "pp_raw": "struck", "past": "struck", "pp": "struck", "es": "golpear", "ca": "colpejar", "ka": "áƒ“áƒáƒ áƒ¢áƒ§áƒ›áƒ"}, {"inf": "swear", "past_raw": "swore", "pp_raw": "sworn", "past": "swore", "pp": "sworn", "es": "jurar", "ca": "jurar", "ka": "áƒ¤áƒ˜áƒªáƒ”áƒ‘áƒ"}, {"inf": "sweep", "past_raw": "swept", "pp_raw": "swept", "past": "swept", "pp": "swept", "es": "barrer", "ca": "escombrar", "ka": "áƒ›áƒáƒ®áƒ•áƒ”áƒ¢áƒ"}, {"inf": "swim", "past_raw": "swam", "pp_raw": "swum", "past": "swam", "pp": "swum", "es": "nadar", "ca": "nedar", "ka": "áƒªáƒ£áƒ áƒ•áƒ"}, {"inf": "take", "past_raw": "took", "pp_raw": "taken", "past": "took", "pp": "taken", "es": "tomar / coger", "ca": "agafar / prendre", "ka": "áƒáƒ¦áƒ”áƒ‘áƒ"}, {"inf": "teach", "past_raw": "taught", "pp_raw": "taught", "past": "taught", "pp": "taught", "es": "enseÃ±ar", "ca": "ensenyar", "ka": "áƒ¡áƒ¬áƒáƒ•áƒšáƒ”áƒ‘áƒ"}, {"inf": "tear", "past_raw": "tore", "pp_raw": "torn", "past": "tore", "pp": "torn", "es": "rasgar", "ca": "esquinÃ§ar", "ka": "áƒ“áƒáƒ®áƒ”áƒ•áƒ"}, {"inf": "tell", "past_raw": "told", "pp_raw": "told", "past": "told", "pp": "told", "es": "decir / contar", "ca": "dir / explicar", "ka": "áƒ›áƒáƒ§áƒáƒšáƒ / áƒ—áƒ¥áƒ›áƒ"}, {"inf": "think", "past_raw": "thought", "pp_raw": "thought", "past": "thought", "pp": "thought", "es": "pensar", "ca": "pensar", "ka": "áƒ¤áƒ˜áƒ¥áƒ áƒ˜"}, {"inf": "throw", "past_raw": "threw", "pp_raw": "thrown", "past": "threw", "pp": "thrown", "es": "tirar / lanzar", "ca": "llenÃ§ar", "ka": "áƒ’áƒáƒ“áƒáƒ’áƒ“áƒ”áƒ‘áƒ"}, {"inf": "tread", "past_raw": "trode", "pp_raw": "trodden/trod", "past": "trode", "pp": "trodden", "es": "pisar", "ca": "trepitjar", "ka": "áƒ¤áƒ”áƒ®áƒ˜áƒ¡ áƒ“áƒáƒ“áƒ’áƒ›áƒ / áƒ’áƒáƒ—áƒ”áƒšáƒ•áƒ"}, {"inf": "understand", "past_raw": "understood", "pp_raw": "understood", "past": "understood", "pp": "understood", "es": "entender", "ca": "entendre", "ka": "áƒ’áƒáƒ’áƒ”áƒ‘áƒ"}, {"inf": "wake", "past_raw": "woke", "pp_raw": "woken", "past": "woke", "pp": "woken", "es": "despertar(se)", "ca": "despertar(-se)", "ka": "áƒ’áƒáƒ¦áƒ•áƒ˜áƒ«áƒ”áƒ‘áƒ"}, {"inf": "wear", "past_raw": "wore", "pp_raw": "worn", "past": "wore", "pp": "worn", "es": "llevar puesto / vestir", "ca": "portar (roba) / vestir", "ka": "áƒ¢áƒáƒ áƒ”áƒ‘áƒ / áƒ©áƒáƒªáƒ›áƒ"}, {"inf": "weave", "past_raw": "wove", "pp_raw": "woven", "past": "wove", "pp": "woven", "es": "tejer", "ca": "teixir", "ka": "áƒ¥áƒ¡áƒáƒ•áƒ"}, {"inf": "weep", "past_raw": "wept", "pp_raw": "wept", "past": "wept", "pp": "wept", "es": "llorar", "ca": "plorar", "ka": "áƒ¢áƒ˜áƒ áƒ˜áƒšáƒ˜"}, {"inf": "win", "past_raw": "won", "pp_raw": "won", "past": "won", "pp": "won", "es": "ganar", "ca": "guanyar", "ka": "áƒ›áƒáƒ’áƒ”áƒ‘áƒ"}, {"inf": "wring", "past_raw": "wrung", "pp_raw": "wrung", "past": "wrung", "pp": "wrung", "es": "retorcer / escurrir", "ca": "torÃ§ar / escÃ³rrer", "ka": "áƒ’áƒáƒ›áƒáƒ¬áƒ£áƒ áƒ•áƒ"}, {"inf": "write", "past_raw": "wrote", "pp_raw": "written", "past": "wrote", "pp": "written", "es": "escribir", "ca": "escriure", "ka": "áƒ¬áƒ”áƒ áƒ"}];

/* Correccions de traducciÃ³ al catalÃ  (evita ambigÃ¼itats sense revelar la resposta) */
const CA_OVERRIDES = {
  "hit": "tocar / colpejar",
  "strike": "colpejar",
  "beat": "batre / vÃ¨ncer"
};
function displayCa(v){
  const inf = v && v.inf ? v.inf : "";
  return (CA_OVERRIDES[inf] || (v && v.ca) || (v && v.inf) || "").trim();
}
const DEV_UNLOCK = new URLSearchParams(location.search).get("dev") === "1";
if(DEV_UNLOCK) document.getElementById("devHint").classList.remove("hidden");

const LANG_KEY = "irregular_verbs_lang_v1";
const UI = {
  ca: {
    title: "Joc de verbs irregulars (anglÃ¨s)",
    subtitle: "6 nivells. No pots pujar de nivell fins que hagis encertat <b>tots</b> els verbs almenys 1 cop.",
    howItWorks: "Com funciona",
    reset: "Reinicia",
    list: "Llista de verbs",
    progress: "ProgrÃ©s del nivell",
    correctWrong: (c,w)=>`Encerts: ${c} Â· Errors: ${w}`,
    masteredLine: (m,t)=>`Dominats aquest nivell: ${m} / ${t}`,
    question: "Pregunta:",
    next: "SegÃ¼ent",
    selectLevelToStart: "Selecciona un nivell per comenÃ§ar",
    lockedLevel: "ğŸ”’ Aquest nivell estÃ  bloquejat. Completa el nivell anterior primer.",
    helpTitle: "Com funciona",
    helpBody: `<ul class="list-disc pl-5 space-y-1">
      <li><b>N1</b>: tria el significat en catalÃ .</li>
      <li><b>N2</b>: tria l'infinitiu en anglÃ¨s a partir del catalÃ .</li>
      <li><b>N3</b>: completa el verb en anglÃ¨s amb lletres.</li>
      <li><b>N4</b>: tria el <b>Simple Past</b> correcte.</li>
      <li><b>N5</b>: tria el <b>Past Participle</b> correcte.</li>
      <li><b>N6</b>: omple infinitive + simple past + past participle (pots provar tantes vegades com calgui).</li>
    </ul>`,
    ok: "D'acord",
    lvlCompleted: (lvl)=>UI[getLang()].lvlCompleted(lvl),
    lvlCompletedBody: (lvl)=>`<p>Has encertat <b>tots</b> els verbs almenys una vegada.</p><p class="mt-2">Ja pots desbloquejar el <b>Nivell ${lvl+1}</b>.</p>`,
    gameDoneTitle: "ğŸ‰ Joc completat!",
    gameDoneBody: "<p>Has completat tots els nivells amb tots els verbs!</p>",
    level: (lvl)=>`Nivell ${lvl}`,
    hintL1: "Tria el significat en catalÃ :",
    hintL2: "Tria el verb en anglÃ¨s (infinitiu):",
    hintL3: "Completa el verb en anglÃ¨s amb les lletres:",
    hintL4: "Tria el SIMPLE PAST correcte:",
    hintL5: "Tria el PAST PARTICIPLE correcte:",
    hintL6: "Omple <b>infinitive + simple past + past participle</b>. Pots comprovar tantes vegades com calgui fins encertar les 3.",
    good: "ğŸ˜Š Molt bÃ©!",
    notCorrect: "ğŸ˜¢ No Ã©s correcte.",
    needAllSelects: "ğŸ˜• Selecciona una opciÃ³ a cada desplegable.",
    stillNot: "ğŸ˜¢ Encara no. Revisa els selectors en vermell i torna a provar.",
    lvl6Good: "ğŸ˜Š Molt bÃ©! (Nivell 6 completat per aquest verb)",
    pronounceTitle: "Escoltar pronunciaciÃ³",
    letterExplain: '<span id="lblLetterExplain">Clica les lletres correctes. Si Ã©s correcta, es posarÃ  automÃ ticament al seu lloc. Les incorrectes es marcaran amb una <span class="text-red-600 font-black">âœ–</span>.</span>',
    listTitle: "Llista de verbs irregulars",
    listSubtitle: "Infinitive, Simple Past, Past Participle i significat.",
    searchPh: "Cerca (infinitiu / formes / significat)...",
    close: "Tancar",
    colors: {
      label: "Colors:",
      easy: "FÃ cils (3 iguals)",
      mid: "Mitjans (2 iguals)",
      hard: "DifÃ­cils (3 diferents)"
    },
    meaningHeader: "CatalÃ "
  },
  es: {
    title: "Juego de verbos irregulares (inglÃ©s)",
    subtitle: "6 niveles. No puedes subir de nivel hasta acertar <b>todos</b> los verbos al menos 1 vez.",
    howItWorks: "CÃ³mo funciona",
    reset: "Reiniciar",
    list: "Lista de verbos",
    progress: "Progreso del nivel",
    correctWrong: (c,w)=>`Aciertos: ${c} Â· Errores: ${w}`,
    masteredLine: (m,t)=>`Dominados en este nivel: ${m} / ${t}`,
    question: "Pregunta:",
    next: "Siguiente",
    selectLevelToStart: "Selecciona un nivel para empezar",
    lockedLevel: "ğŸ”’ Este nivel estÃ¡ bloqueado. Completa el nivel anterior primero.",
    helpTitle: "CÃ³mo funciona",
    helpBody: `<ul class="list-disc pl-5 space-y-1">
      <li><b>N1</b>: elige el significado en catalÃ¡n.</li>
      <li><b>N2</b>: elige el infinitivo en inglÃ©s a partir del catalÃ¡n.</li>
      <li><b>N3</b>: completa el verbo en inglÃ©s con letras.</li>
      <li><b>N4</b>: elige el <b>Simple Past</b> correcto.</li>
      <li><b>N5</b>: elige el <b>Past Participle</b> correcto.</li>
      <li><b>N6</b>: rellena infinitive + simple past + past participle (puedes intentarlo las veces que haga falta).</li>
    </ul>`,
    ok: "Vale",
    lvlCompleted: (lvl)=>`Â¡Nivel ${lvl} completado!`,
    lvlCompletedBody: (lvl)=>`<p>Has acertado <b>todos</b> los verbos al menos una vez.</p><p class="mt-2">Ya puedes desbloquear el <b>Nivel ${lvl+1}</b>.</p>`,
    gameDoneTitle: "ğŸ‰ Â¡Juego completado!",
    gameDoneBody: "<p>Has completado todos los niveles con todos los verbos.</p>",
    level: (lvl)=>`Nivel ${lvl}`,
    hintL1: "Elige el significado en catalÃ¡n:",
    hintL2: "Elige el verbo en inglÃ©s (infinitivo):",
    hintL3: "Completa el verbo en inglÃ©s con las letras:",
    hintL4: "Elige el SIMPLE PAST correcto:",
    hintL5: "Elige el PAST PARTICIPLE correcto:",
    hintL6: "Rellena <b>infinitive + simple past + past participle</b>. Puedes comprobarlo tantas veces como haga falta hasta acertar las 3.",
    good: "ğŸ˜Š Â¡Muy bien!",
    notCorrect: "ğŸ˜¢ No es correcto.",
    needAllSelects: "ğŸ˜• Selecciona una opciÃ³n en cada desplegable.",
    stillNot: "ğŸ˜¢ AÃºn no. Revisa los selectores en rojo y vuelve a probar.",
    lvl6Good: "ğŸ˜Š Â¡Muy bien! (Nivel 6 completado para este verbo)",
    pronounceTitle: "Escuchar pronunciaciÃ³n",
    letterExplain: 'Haz clic en las letras correctas. Si es correcta, se colocarÃ¡ automÃ¡ticamente en su sitio. Las incorrectas se marcarÃ¡n con una <span class="text-red-600 font-black">âœ–</span>.',
    listTitle: "Lista de verbos irregulares",
    listSubtitle: "Infinitive, Simple Past, Past Participle y significado.",
    searchPh: "Buscar (infinitivo / formas / significado)...",
    close: "Cerrar",
    colors: { label:"Colores:", easy:"FÃ¡ciles (3 iguales)", mid:"Medios (2 iguales)", hard:"DifÃ­ciles (3 diferentes)" },
    meaningHeader: "Castellano"
  },
  ka: {
    title: "áƒáƒ áƒáƒ áƒ”áƒ’áƒ£áƒšáƒáƒ áƒ£áƒšáƒ˜ áƒ–áƒ›áƒœáƒ”áƒ‘áƒ˜áƒ¡ áƒ—áƒáƒ›áƒáƒ¨áƒ˜ (áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒ˜)",
    subtitle: "6 áƒ“áƒáƒœáƒ”. áƒ•áƒ”áƒ  áƒ’áƒáƒ“áƒáƒ®áƒ•áƒáƒš áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’ áƒ“áƒáƒœáƒ”áƒ–áƒ” áƒ¡áƒáƒœáƒáƒ› <b>áƒ§áƒ•áƒ”áƒšáƒ</b> áƒ–áƒ›áƒœáƒáƒ¡ áƒ›áƒ˜áƒœáƒ˜áƒ›áƒ£áƒ› áƒ”áƒ áƒ—áƒ®áƒ”áƒš áƒáƒ  áƒ’áƒáƒ›áƒáƒ˜áƒªáƒœáƒáƒ‘.",
    howItWorks: "áƒ áƒáƒ’áƒáƒ  áƒ›áƒ£áƒ¨áƒáƒáƒ‘áƒ¡",
    reset: "áƒ’áƒáƒ“áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ•áƒ",
    list: "áƒ–áƒ›áƒœáƒ”áƒ‘áƒ˜áƒ¡ áƒ¡áƒ˜áƒ",
    progress: "áƒ“áƒáƒœáƒ˜áƒ¡ áƒáƒ áƒáƒ’áƒ áƒ”áƒ¡áƒ˜",
    correctWrong: (c,w)=>`áƒ¡áƒ¬áƒáƒ áƒ˜: ${c} Â· áƒ¨áƒ”áƒªáƒ“áƒáƒ›áƒ: ${w}`,
    masteredLine: (m,t)=>`áƒáƒ› áƒ“áƒáƒœáƒ”áƒ–áƒ” áƒ“áƒáƒ›áƒáƒ®áƒ¡áƒáƒ•áƒ áƒ”áƒ‘áƒ£áƒšáƒ˜: ${m} / ${t}`,
    question: "áƒ™áƒ˜áƒ—áƒ®áƒ•áƒ:",
    next: "áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’áƒ˜",
    selectLevelToStart: "áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ“áƒáƒœáƒ” áƒ“áƒáƒ¡áƒáƒ¬áƒ§áƒ”áƒ‘áƒáƒ“",
    lockedLevel: "ğŸ”’ áƒ”áƒ¡ áƒ“áƒáƒœáƒ” áƒ“áƒáƒ‘áƒšáƒáƒ™áƒ˜áƒšáƒ˜áƒ. áƒ¯áƒ”áƒ  áƒ“áƒáƒáƒ¡áƒ áƒ£áƒšáƒ” áƒ¬áƒ˜áƒœáƒ áƒ“áƒáƒœáƒ”.",
    helpTitle: "áƒ áƒáƒ’áƒáƒ  áƒ›áƒ£áƒ¨áƒáƒáƒ‘áƒ¡",
    helpBody: `<ul class="list-disc pl-5 space-y-1">
      <li><b>N1</b>: áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ áƒ™áƒáƒ¢áƒáƒšáƒáƒœáƒ£áƒ áƒáƒ“.</li>
      <li><b>N2</b>: áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒ˜ áƒ˜áƒœáƒ¤áƒ˜áƒœáƒ˜áƒ¢áƒ˜áƒ•áƒ˜ áƒ™áƒáƒ¢áƒáƒšáƒáƒœáƒ£áƒ áƒ˜áƒ“áƒáƒœ.</li>
      <li><b>N3</b>: áƒ¨áƒ”áƒáƒ“áƒ’áƒ˜áƒœáƒ” áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒ˜ áƒ–áƒ›áƒœáƒ áƒáƒ¡áƒáƒ”áƒ‘áƒ˜áƒ—.</li>
      <li><b>N4</b>: áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ¡áƒ¬áƒáƒ áƒ˜ <b>Simple Past</b>.</li>
      <li><b>N5</b>: áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ¡áƒ¬áƒáƒ áƒ˜ <b>Past Participle</b>.</li>
      <li><b>N6</b>: áƒ¨áƒ”áƒáƒ•áƒ¡áƒ” infinitive + simple past + past participle (áƒ¨áƒ”áƒ’áƒ˜áƒ«áƒšáƒ˜áƒ áƒ áƒáƒ›áƒ“áƒ”áƒœáƒ¯áƒ”áƒ áƒáƒª áƒ’áƒ˜áƒœáƒ“áƒ áƒ¡áƒªáƒáƒ“áƒ).</li>
    </ul>`,
    ok: "áƒ™áƒáƒ áƒ’áƒ˜",
    lvlCompleted: (lvl)=>`áƒ“áƒáƒœáƒ” ${lvl} áƒ“áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ£áƒšáƒ˜áƒ!`,
    lvlCompletedBody: (lvl)=>`<p>áƒ§áƒ•áƒ”áƒšáƒ áƒ–áƒ›áƒœáƒ áƒ›áƒ˜áƒœáƒ˜áƒ›áƒ£áƒ› áƒ”áƒ áƒ—áƒ®áƒ”áƒš áƒ¡áƒ¬áƒáƒ áƒáƒ“ áƒ’áƒáƒ›áƒáƒ˜áƒªáƒáƒœáƒ˜.</p><p class="mt-2">áƒáƒ®áƒšáƒ áƒ¨áƒ”áƒ’áƒ˜áƒ«áƒšáƒ˜áƒ áƒ’áƒáƒ®áƒ¡áƒœáƒ <b>áƒ“áƒáƒœáƒ” ${lvl+1}</b>.</p>`,
    gameDoneTitle: "ğŸ‰ áƒ—áƒáƒ›áƒáƒ¨áƒ˜ áƒ“áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ£áƒšáƒ˜áƒ!",
    gameDoneBody: "<p>áƒ§áƒ•áƒ”áƒšáƒ áƒ“áƒáƒœáƒ” áƒ“áƒ áƒ§áƒ•áƒ”áƒšáƒ áƒ–áƒ›áƒœáƒ áƒ“áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ£áƒšáƒ˜áƒ.</p>",
    level: (lvl)=>`áƒ“áƒáƒœáƒ” ${lvl}`,
    hintL1: "áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ áƒ™áƒáƒ¢áƒáƒšáƒáƒœáƒ£áƒ áƒáƒ“:",
    hintL2: "áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ–áƒ›áƒœáƒ áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒáƒ“ (áƒ˜áƒœáƒ¤áƒ˜áƒœáƒ˜áƒ¢áƒ˜áƒ•áƒ˜):",
    hintL3: "áƒ¨áƒ”áƒáƒ“áƒ’áƒ˜áƒœáƒ” áƒ–áƒ›áƒœáƒ áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒáƒ“ áƒáƒ¡áƒáƒ”áƒ‘áƒ˜áƒ—:",
    hintL4: "áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ¡áƒ¬áƒáƒ áƒ˜ SIMPLE PAST:",
    hintL5: "áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ¡áƒ¬áƒáƒ áƒ˜ PAST PARTICIPLE:",
    hintL6: "áƒ¨áƒ”áƒáƒ•áƒ¡áƒ” <b>infinitive + simple past + past participle</b>. áƒ¨áƒ”áƒáƒ›áƒáƒ¬áƒ›áƒ” áƒ áƒáƒ›áƒ“áƒ”áƒœáƒ¯áƒ”áƒ áƒáƒª áƒ’áƒ˜áƒœáƒ“áƒ, áƒ¡áƒáƒœáƒáƒ› áƒ¡áƒáƒ›áƒ˜áƒ•áƒ” áƒ¡áƒ¬áƒáƒ áƒ˜áƒ.",
    good: "ğŸ˜Š áƒ™áƒáƒ áƒ’áƒ˜!",
    notCorrect: "ğŸ˜¢ áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜áƒ.",
    needAllSelects: "ğŸ˜• áƒ—áƒ˜áƒ—áƒáƒ”áƒ£áƒš áƒ©áƒáƒ›áƒáƒ¡áƒáƒ¨áƒšáƒ”áƒšáƒ¨áƒ˜ áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ•áƒáƒ áƒ˜áƒáƒœáƒ¢áƒ˜.",
    stillNot: "ğŸ˜¢ áƒ¯áƒ”áƒ  áƒáƒ áƒ. áƒ’áƒáƒ“áƒáƒáƒ›áƒáƒ¬áƒ›áƒ” áƒ¬áƒ˜áƒ—áƒšáƒáƒ“ áƒ›áƒáƒœáƒ˜áƒ¨áƒœáƒ£áƒšáƒ˜ áƒ“áƒ áƒ¡áƒªáƒáƒ“áƒ” áƒ—áƒáƒ•áƒ˜áƒ“áƒáƒœ.",
    lvl6Good: "ğŸ˜Š áƒ™áƒáƒ áƒ’áƒ˜! (áƒ“áƒáƒœáƒ” 6 áƒ“áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ£áƒšáƒ˜áƒ áƒáƒ› áƒ–áƒ›áƒœáƒ˜áƒ¡áƒ—áƒ•áƒ˜áƒ¡)",
    pronounceTitle: "áƒ’áƒáƒ›áƒáƒ—áƒ¥áƒ›áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ›áƒ”áƒœáƒ",
    letterExplain: 'áƒ“áƒáƒáƒ­áƒ˜áƒ áƒ” áƒ¡áƒ¬áƒáƒ  áƒáƒ¡áƒáƒ”áƒ‘áƒ¡. áƒ—áƒ£ áƒ¡áƒ¬áƒáƒ áƒ˜áƒ, áƒáƒ•áƒ¢áƒáƒ›áƒáƒ¢áƒ£áƒ áƒáƒ“ áƒ“áƒáƒ“áƒ’áƒ”áƒ‘áƒ áƒ—áƒáƒ•áƒ˜áƒ¡ áƒáƒ“áƒ’áƒ˜áƒšáƒ–áƒ”. áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒáƒ¡áƒáƒ”áƒ‘áƒ˜ áƒ›áƒáƒœáƒ˜áƒ¨áƒœáƒ“áƒ”áƒ‘áƒ <span class="text-red-600 font-black">âœ–</span>-áƒ˜áƒ—.',
    listTitle: "áƒáƒ áƒáƒ áƒ”áƒ’áƒ£áƒšáƒáƒ áƒ£áƒšáƒ˜ áƒ–áƒ›áƒœáƒ”áƒ‘áƒ˜áƒ¡ áƒ¡áƒ˜áƒ",
    listSubtitle: "Infinitive, Simple Past, Past Participle áƒ“áƒ áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ.",
    searchPh: "áƒ«áƒ”áƒ‘áƒœáƒ (infinitive / forms / meaning)...",
    close: "áƒ“áƒáƒ®áƒ£áƒ áƒ•áƒ",
    colors: { label:"áƒ¤áƒ”áƒ áƒ”áƒ‘áƒ˜:", easy:"áƒ›áƒáƒ áƒ¢áƒ˜áƒ•áƒ˜ (3 áƒ”áƒ áƒ—áƒœáƒáƒ˜áƒ áƒ˜)", mid:"áƒ¡áƒáƒ¨áƒ£áƒáƒšáƒ (2 áƒ”áƒ áƒ—áƒœáƒáƒ˜áƒ áƒ˜)", hard:"áƒ áƒ—áƒ£áƒšáƒ˜ (3 áƒ’áƒáƒœáƒ¡áƒ®áƒ•áƒáƒ•áƒ”áƒ‘áƒ£áƒšáƒ˜)" },
    meaningHeader: "áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ"
  }
};
function getLang(){
  const saved = localStorage.getItem(LANG_KEY);
  return (saved==="ca"||saved==="es"||saved==="ka") ? saved : "ca";
}
function setLang(lang){
  if(!(lang==="ca"||lang==="es"||lang==="ka")) lang="ca";
  localStorage.setItem(LANG_KEY, lang);
}
function t(key){
  const lang = getLang();
  return UI[lang][key] ?? UI.ca[key] ?? key;
}
function meaningForLang(v){
  const lang = getLang();
  if(lang==="es") return (v.es || v.ca || v.inf || "").trim();
  if(lang==="ka") return (v.ka || v.es || v.ca || v.inf || "").trim();
  return displayCa(v);
}

const STORE_KEY = "irregular_verbs_game_v4";

const els = {
  levelBar: document.getElementById("levelBar"),
  levelBtns: () => Array.from(document.querySelectorAll(".levelBtn")),
  btnReset: document.getElementById("btnReset"),
  btnList: document.getElementById("btnList"),
  btnHelp: document.getElementById("btnHelp"),
  btnSpeak: document.getElementById("btnSpeak"),
  langSel: document.getElementById("langSel"),
  audioModeSel: document.getElementById("audioModeSel"),
  chkOnlyMarked: document.getElementById("chkOnlyMarked"),
  quizArea: document.getElementById("quizArea"),
  levelTitle: document.getElementById("levelTitle"),
  questionText: document.getElementById("questionText"),
  questionHint: document.getElementById("questionHint"),
  answers: document.getElementById("answers"),
  feedback: document.getElementById("feedback"),
  btnNext: document.getElementById("btnNext"),
  qIndex: document.getElementById("qIndex"),
  qTotal: document.getElementById("qTotal"),
  progressBar: document.getElementById("progressBar"),
  progressPct: document.getElementById("progressPct"),
  scoreLine: document.getElementById("scoreLine"),
  masterLine: document.getElementById("masterLine"),
  modal: document.getElementById("modal"),
  modalTitle: document.getElementById("modalTitle"),
  modalBody: document.getElementById("modalBody"),
  modalClose: document.getElementById("modalClose"),
  modalOk: document.getElementById("modalOk"),
  level6Area: document.getElementById("level6Area"),
  // nivell 3
  level3Letters: document.getElementById("level3Letters"),
  letterSlots: document.getElementById("letterSlots"),
  letterBank: document.getElementById("letterBank"),
  selInf: document.getElementById("selInf"),
  selPast: document.getElementById("selPast"),
  selPP: document.getElementById("selPP"),
  btnCheckLevel6: document.getElementById("btnCheckLevel6"),
};

function initialState() {
  const progress = {};
  const retries = {};
  for (const lvl of [1,2,3,4,5,6]) {
    progress[lvl] = { mastered: {}, correct: 0, wrong: 0 };
    retries[lvl] = [];
  }
  return { currentLevel: 1, queue: [], current: null, answered: false, progress, retries, marked: {}, onlyMarked: false, audioMode: "manual" };
}
function loadState() {
  try {
    const raw = localStorage.getItem(STORE_KEY);
    if(!raw) return initialState();
    const st = JSON.parse(raw);
    if(!st.progress) st.progress = initialState().progress;
    if(!st.retries) st.retries = initialState().retries;
    for (const lvl of [1,2,3,4,5,6]) {
      st.progress[lvl] = st.progress[lvl] || { mastered: {}, correct: 0, wrong: 0 };
      st.progress[lvl].mastered = st.progress[lvl].mastered || {};
      st.progress[lvl].correct = st.progress[lvl].correct || 0;
      st.progress[lvl].wrong = st.progress[lvl].wrong || 0;
      st.retries[lvl] = Array.isArray(st.retries[lvl]) ? st.retries[lvl] : [];
    }
    st.currentLevel = st.currentLevel || 1;
    st.queue = Array.isArray(st.queue) ? st.queue : [];
    st.current = st.current || null;
    st.answered = !!st.answered;
    st.marked = (st.marked && typeof st.marked === "object") ? st.marked : {};
    st.onlyMarked = !!st.onlyMarked;
    st.audioMode = (st.audioMode==="auto" || st.audioMode==="manual") ? st.audioMode : "manual";
    return st;
  } catch(e) {
    return initialState();
  }
}

function applyLanguage(){
  const lang = getLang();
  document.documentElement.lang = lang;
  const sel = document.getElementById("langSel");
  if(sel && sel.value !== lang) sel.value = lang;

  // Header texts
  const titleEl = document.getElementById("appTitle");
  const subEl = document.getElementById("appSubtitle");
  if(titleEl) titleEl.textContent = UI[lang].title;
  if(subEl) subEl.innerHTML = UI[lang].subtitle;

  const lblProg = document.getElementById("lblProgress");
  if(lblProg) lblProg.textContent = UI[lang].progress;

  const lblQ = document.getElementById("lblQuestion");
  if(lblQ) lblQ.textContent = UI[lang].question;

  // Buttons
  if(els.btnHelp) els.btnHelp.textContent = UI[lang].howItWorks;
  if(els.btnReset) els.btnReset.textContent = UI[lang].reset;
  if(els.btnList) els.btnList.textContent = UI[lang].list;
  if(els.btnNext) els.btnNext.textContent = UI[lang].next;
  if(els.btnSpeak) els.btnSpeak.title = UI[lang].pronounceTitle;

  const explain = document.getElementById("lblLetterExplain");
  if(explain) explain.innerHTML = UI[lang].letterExplain;

  // Modal button
  if(els.modalOk) els.modalOk.textContent = UI[lang].ok;

  // Extras (global)
  const onlyLbl = document.getElementById("lblOnlyMarked");
  if(onlyLbl) onlyLbl.textContent = (lang==="es") ? "Solo marcados" : (lang==="ka") ? "áƒ›áƒ®áƒáƒšáƒáƒ“ áƒ›áƒáƒœáƒ˜áƒ¨áƒœáƒ£áƒšáƒ”áƒ‘áƒ˜" : "NomÃ©s marcats";
  if(els.chkOnlyMarked) els.chkOnlyMarked.checked = !!state.onlyMarked;
  if(els.audioModeSel){
    const audioLabel = els.audioModeSel.closest("div")?.querySelector("label");
    if(audioLabel) audioLabel.textContent = (lang==="es") ? "Audio" : (lang==="ka") ? "áƒáƒ£áƒ“áƒ˜áƒ" : "Ã€udio";
    // options
    const opts = Array.from(els.audioModeSel.querySelectorAll("option"));
    if(opts[0]) opts[0].textContent = (lang==="es") ? "Manual" : (lang==="ka") ? "áƒ®áƒ”áƒšáƒ˜áƒ—" : "Manual";
    if(opts[1]) opts[1].textContent = (lang==="es") ? "AutomÃ¡tico" : (lang==="ka") ? "áƒáƒ•áƒ¢áƒáƒ›áƒáƒ¢áƒ£áƒ áƒ˜" : "AutomÃ tic";
  }


  // If we are on a question, re-render current question (without advancing)
  if(state && state.current){
    // Keep answered state; just re-render prompt/labels
    els.levelTitle.textContent = UI[lang].level(state.currentLevel);
    if(!state.answered){
      // rebuild current question fully for correct language
      const cur = state.current;
      clearAnswers();
      setFeedback("");
      setNextEnabled(false);
      if(state.currentLevel===1) buildLevel1(cur);
      else if(state.currentLevel===2) buildLevel2(cur);
      else if(state.currentLevel===3) buildLevel3(cur);
      else if(state.currentLevel===4) buildLevel4(cur);
      else if(state.currentLevel===5) buildLevel5(cur);
      else if(state.currentLevel===6) buildLevel6(cur);
    } else {
      // Only update question text/ hint
      if(state.currentLevel===1) { els.questionText.textContent = state.current.inf; els.questionHint.textContent = UI[lang].hintL1; }
      if(state.currentLevel===2) { els.questionText.textContent = meaningForLang(state.current); els.questionHint.textContent = UI[lang].hintL2; }
      if(state.currentLevel===3) { els.questionText.textContent = meaningForLang(state.current); els.questionHint.textContent = UI[lang].hintL3; }
      if(state.currentLevel===4) { els.questionHint.textContent = UI[lang].hintL4; }
      if(state.currentLevel===5) { els.questionHint.textContent = UI[lang].hintL5; }
      if(state.currentLevel===6) { els.questionHint.innerHTML = UI[lang].hintL6; }
    }
  } else {
    els.levelTitle.textContent = UI[lang].level(1);
    els.questionText.textContent = UI[lang].selectLevelToStart;
    els.questionHint.textContent = "";
  }
  updateStatsUI();
}

let state = loadState();
function saveState(){ localStorage.setItem(STORE_KEY, JSON.stringify(state)); }

function openModal(title, bodyHtml) {
  els.modalTitle.textContent = title;
  els.modalBody.innerHTML = bodyHtml;
  els.modal.classList.remove("hidden");
  els.modal.classList.add("flex");
}
function closeModal() {
  els.modal.classList.add("hidden");
  els.modal.classList.remove("flex");
}
els.modalClose.addEventListener("click", closeModal);
els.modalOk.addEventListener("click", closeModal);
els.modal.addEventListener("click", (e)=>{ if(e.target === els.modal) closeModal(); });

function shuffle(arr) {
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--) {
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function uniq(arr){ return Array.from(new Set(arr)); }
function pct(n,d){ if(d<=0) return 0; return Math.round((n/d)*100); }
function allInfs(){ return DEFAULT_VERBS.map(v=>v.inf); }
function getVerb(inf){ return DEFAULT_VERBS.find(v=>v.inf===inf); }
function countMastered(lvl){ return Object.keys(state.progress[lvl].mastered || {}).length; }

function isLevelUnlocked(lvl){
  return true; // tots els nivells disponibles
}
function updateLevelButtons(){
  els.levelBtns().forEach(btn=>{
    const lvl = parseInt(btn.dataset.level,10);
    btn.classList.remove("btn-disabled");
    btn.innerHTML = `N${lvl}`;
  });
}
function updateStatsUI(){
  const lvl = state.currentLevel;
  const mastered = countMastered(lvl);
  const total = DEFAULT_VERBS.length;
  const p = pct(mastered, total);
  els.progressBar.style.width = `${p}%`;
  els.progressPct.textContent = `${p}%`;
  els.scoreLine.textContent = UI[getLang()].correctWrong(state.progress[lvl].correct, state.progress[lvl].wrong);
  els.masterLine.textContent = UI[getLang()].masteredLine(mastered, total);
  updateLevelButtons();
}

function setFeedback(html, ok=true){
  els.feedback.innerHTML = html || "";
  els.feedback.className = "text-base font-bold text-center " + (ok ? "text-green-600" : "text-red-600");
}
function clearAnswers(){
  els.answers.innerHTML = "";
  els.level6Area.classList.add("hidden");
  els.level3Letters.classList.add("hidden");
}
function setNextEnabled(enabled){
  els.btnNext.disabled = !enabled;
  if(enabled){
    els.btnNext.classList.remove("bg-blue-300","hover:bg-blue-300");
    els.btnNext.classList.add("bg-blue-500","hover:bg-blue-600");
  } else {
    els.btnNext.classList.add("bg-blue-300","hover:bg-blue-300");
    els.btnNext.classList.remove("bg-blue-500","hover:bg-blue-600");
  }
}
function wiggle(){
  els.quizArea.classList.remove("shake");
  void els.quizArea.offsetWidth;
  els.quizArea.classList.add("shake");
}


/* PronunciaciÃ³ (Web Speech API) */
function canSpeak(){
  return ("speechSynthesis" in window) && ("SpeechSynthesisUtterance" in window);
}
function speakEN(text){
  try{
    if(!canSpeak()) return;
    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    // Try to prefer English voice if available
    const voices = window.speechSynthesis.getVoices?.() || [];
    const enVoice = voices.find(v=> (v.lang||"").toLowerCase().startsWith("en"));
    if(enVoice) u.voice = enVoice;
    u.lang = (enVoice && enVoice.lang) ? enVoice.lang : "en-US";
    u.rate = 0.95;
    window.speechSynthesis.speak(u);
  } catch(e){}
}
function speakSequence(words){
  if(!canSpeak()) return;
  const cleaned = words.map(w=>String(w||"").trim()).filter(Boolean);
  if(!cleaned.length) return;
  // cancel previous
  speechSynthesis.cancel();
  let i=0;
  const speakNext = ()=>{
    if(i>=cleaned.length) return;
    const u = new SpeechSynthesisUtterance(cleaned[i]);
    u.lang = "en-US";
    u.rate = 0.95;
    u.onend = ()=>{ i++; speakNext(); };
    u.onerror = ()=>{ i++; speakNext(); };
    speechSynthesis.speak(u);
  };
  speakNext();
}

function speakAutoForCurrent(){
  if(state.audioMode!=="auto") return;
  if(!canSpeak()) return;
  const lvl = state.currentLevel;
  const v = state.current;
  const words = [];
  if(v && v.inf){
    if([1,4,5].includes(lvl)) words.push(v.inf);
  }
  // read answer options that look like English forms (buttons in answers)
  const btns = Array.from(els.answers.querySelectorAll("button")).filter(b=>!b.disabled);
  btns.forEach(b=>{
    const t = (b.textContent||"").trim();
    if(/^[A-Za-z][A-Za-z\-\s\/]*$/.test(t)) words.push(t);
  });
  // Level 6: read selected values (not the whole dropdown lists)
  if(lvl===6){
    const sels = Array.from(els.level6Area.querySelectorAll("select"));
    sels.forEach(s=>{
      const t = (s.value||"").trim();
      if(/^[A-Za-z][A-Za-z\-\s\/]*$/.test(t)) words.push(t);
    });
  }
  if(words.length) speakSequence(words);
}

function updateSpeakButton(v){
  // Main pronounce button: show in levels where the English infinitive is visible in the question
  const show = ([1,4,5].includes(state.currentLevel)) && canSpeak() && v && v.inf;
  els.btnSpeak.classList.toggle("hidden", !show);
  if(show){
    els.btnSpeak.onclick = ()=> speakEN(v.inf);
  } else {
    els.btnSpeak.onclick = null;
  }
}
// Some browsers load voices async
if("speechSynthesis" in window){
  window.speechSynthesis.onvoiceschanged = ()=> {
    if(state.current && state.currentLevel===1) updateSpeakButton(state.current);
  };
}

/* similarity helpers */
function levenshtein(a,b){
  a=String(a); b=String(b);
  const m=a.length,n=b.length;
  const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
  for(let i=0;i<=m;i++) dp[i][0]=i;
  for(let j=0;j<=n;j++) dp[0][j]=j;
  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const cost=a[i-1]===b[j-1]?0:1;
      dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
    }
  }
  return dp[m][n];
}

/* Genera variants "creÃ¯bles" (typos) per fer mÃ©s difÃ­cil quan el verb Ã©s igual en tots els temps */
function isVowel(ch){ return "aeiou".includes((ch||"").toLowerCase()); }
function typoVariants(word){
  word = String(word||"").trim();
  if(word.length < 3) return [];
  const vars = new Set();

  // 1) canviar una vocal per una altra (sproad, spreat, etc.)
  const vowels = ["a","e","i","o","u"];
  for(let i=0;i<word.length;i++){
    const ch = word[i].toLowerCase();
    if(isVowel(ch)){
      for(const v of vowels){
        if(v===ch) continue;
        vars.add(word.slice(0,i) + v + word.slice(i+1));
      }
    }
  }

  // 2) intercanviar dues lletres adjacents (raed)
  for(let i=0;i<word.length-1;i++){
    if(word[i] !== word[i+1]){
      vars.add(word.slice(0,i) + word[i+1] + word[i] + word.slice(i+2));
    }
  }

  // 3) afegir/eliminar una lletra comuna al final (spreads, spreadd) - poc, perÃ² Ãºtil
  vars.add(word + "s");
  if(word.length>3) vars.add(word.slice(0,-1));

  // Filtre: nomÃ©s variants amb distÃ ncia petita
  const out = Array.from(vars).filter(v=>{
    const d = levenshtein(word, v);
    return d>=1 && d<=2;
  });

  // Prioritza variants amb canvi de vocal o swap (mÃ©s creÃ¯bles)
  return shuffle(out).slice(0, 10);
}

/* Escull distractors molt semblants; si no n'hi ha prou, crea typos */
function hardDistractors(correct, pool, k){
  const scored = pool
    .filter(x=>x!==correct)
    .map(x=>({x, d: levenshtein(correct, x)}))
    .sort((a,b)=>a.d-b.d);

  const chosen = [];
  for(const o of scored){
    if(o.d <= 2) { // nomÃ©s molt semblants
      if(!chosen.includes(o.x)) chosen.push(o.x);
      if(chosen.length>=k) break;
    }
  }

  if(chosen.length < k){
    const typos = typoVariants(correct);
    for(const t of typos){
      if(chosen.length>=k) break;
      if(t!==correct && !chosen.includes(t)) chosen.push(t);
    }
  }

  // Si encara falten, omple amb les mÃ©s semblants disponibles
  if(chosen.length < k){
    for(const o of scored){
      if(chosen.length>=k) break;
      if(!chosen.includes(o.x) && o.x!==correct) chosen.push(o.x);
    }
  }

  return chosen.slice(0,k);
}
function similarDistractors(correctForm, poolForms, k=2){
  const scored = poolForms
    .filter(x=>x!==correctForm)
    .map(x=>({x, d: levenshtein(correctForm, x)}))
    .sort((a,b)=>a.d-b.d);
  const best = scored.slice(0, 30).map(o=>o.x);
  const chosen=[];
  for(const x of best){
    if(chosen.length>=k) break;
    if(!chosen.includes(x) && x!==correctForm) chosen.push(x);
  }
  if(chosen.length<k){
    const rest = shuffle(poolForms.filter(x=>x!==correctForm && !chosen.includes(x)));
    while(chosen.length<k && rest.length) chosen.push(rest.pop());
  }
  return chosen;
}
function uniquePush(arr, v){
  if(v && !arr.includes(v)) arr.push(v);
}

/* per-verb tricky options */
function makeLevel3Options(v){
  const correct = v.past;
  const opts = [correct];

  // pot sortir infinitiu o participi si sÃ³n diferents
  if(v.inf !== correct) uniquePush(opts, v.inf);
  if(v.pp !== correct) uniquePush(opts, v.pp);

  // distractors difÃ­cils: primer molt semblants (o typos si cal)
  const pool = uniq(DEFAULT_VERBS.map(x=>x.past));
  const need = Math.max(0, 3 - opts.length);
  const extras = hardDistractors(correct, pool, need + 2); // en demanem una mica mÃ©s per variar
  for(const x of extras){
    if(opts.length>=3) break;
    uniquePush(opts, x);
  }

  // assegura 3 opcions
  while(opts.length<3){
    uniquePush(opts, hardDistractors(correct, pool, 1)[0] || pool[Math.floor(Math.random()*pool.length)]);
  }

  return { options: shuffle(opts).slice(0,3), correct, extrasUsed: opts.filter(x=>x!==correct) };
}
function makeLevel4Options(v){
  const correct = v.pp;
  const opts = [correct];

  // pot sortir infinitiu o past simple si sÃ³n diferents
  if(v.inf !== correct) uniquePush(opts, v.inf);
  if(v.past !== correct) uniquePush(opts, v.past);

  const pool = uniq(DEFAULT_VERBS.map(x=>x.pp));
  const need = Math.max(0, 3 - opts.length);
  const extras = hardDistractors(correct, pool, need + 2);
  for(const x of extras){
    if(opts.length>=3) break;
    uniquePush(opts, x);
  }

  while(opts.length<3){
    uniquePush(opts, hardDistractors(correct, pool, 1)[0] || pool[Math.floor(Math.random()*pool.length)]);
  }

  return { options: shuffle(opts).slice(0,3), correct, extrasUsed: opts.filter(x=>x!==correct) };
}
function makeLevel5Pool(v){
  const base = [];
  uniquePush(base, v.inf);
  uniquePush(base, v.past);
  uniquePush(base, v.pp);

  const l3 = makeLevel3Options(v).extrasUsed;
  const l4 = makeLevel4Options(v).extrasUsed;
  const tricky = shuffle(uniq(l3.concat(l4))).filter(x=>!base.includes(x));

  for(const x of tricky){
    if(base.length>=5) break;
    uniquePush(base, x);
  }
  const pool = uniq(DEFAULT_VERBS.map(x=>x.past).concat(DEFAULT_VERBS.map(x=>x.pp)).concat(allInfs()));
  const extra = shuffle(pool).filter(x=>!base.includes(x));
  while(base.length<5 && extra.length){
    uniquePush(base, extra.pop());
  }
  return base.slice(0,5);
}

/* Wrong answers return at end (shuffled) */
function addRetry(inf){
  const lvl = state.currentLevel;
  const list = state.retries[lvl] || [];
  if(!list.includes(inf)) list.push(inf);
  state.retries[lvl] = list;
}

function renderMCQ(options, correct, onCorrect){
  els.level6Area.classList.add("hidden");
  els.answers.innerHTML = "";

  // always shuffle options positions
  options = shuffle(options);

  options.forEach((opt)=>{
    const btn=document.createElement("button");
    btn.className="optBtn bg-white border border-slate-200 rounded-xl px-4 py-3 text-left";
    btn.textContent = opt;

    btn.addEventListener("click", ()=>{
      if(state.answered) return;
      state.answered = true;

      const buttons = Array.from(els.answers.querySelectorAll("button"));
      buttons.forEach(b=>{
        b.disabled = true;
        b.classList.add("optLocked");
      });

      const ok = (opt === correct);
      if(ok){
        btn.classList.add("optCorrect");
        setFeedback(UI[getLang()].good, true);
        state.progress[state.currentLevel].correct += 1;
        onCorrect?.();
      } else {
        btn.classList.add("optWrong");
        const correctBtn = buttons.find(b=>b.textContent===correct);
        if(correctBtn) correctBtn.classList.add("optReveal");
        setFeedback(UI[getLang()].notCorrect, false);
        state.progress[state.currentLevel].wrong += 1;
        addRetry(state.current.inf);
        wiggle();
      }

      saveState(); updateStatsUI();
      setNextEnabled(true);
      maybeFinishLevel();
    });

    els.answers.appendChild(btn);
  });

  updateStatsUI();
}

function maybeFinishLevel(){
  const lvl = state.currentLevel;
  if(countMastered(lvl) >= DEFAULT_VERBS.length){
    if(lvl < 6){
      openModal(
        UI[getLang()].lvlCompleted(lvl),
        UI[getLang()].lvlCompletedBody(lvl)
      );
    } else {
      openModal(UI[getLang()].gameDoneTitle, UI[getLang()].gameDoneBody);
    }
  }
}

function buildQueueForLevel(lvl){
  let all = allInfs();
  if(state.onlyMarked){
    const markedInfs = Object.keys(state.marked||{}).filter(k=>state.marked[k]);
    if(markedInfs.length) all = markedInfs;
  }
  const masteredSet = state.progress[lvl].mastered || {};
  const notMastered = all.filter(inf=>!masteredSet[inf]);
  const mastered = all.filter(inf=>!!masteredSet[inf]);
  const pool = shuffle(notMastered.concat(shuffle(mastered).slice(0, Math.min(10, mastered.length))));
  return pool.length ? pool : shuffle(all);
}

function takeNextInf(){
  const lvl = state.currentLevel;
  if(state.queue.length) return state.queue.shift();

  const r = state.retries[lvl] || [];
  if(r.length){
    state.queue = shuffle(r);
    state.retries[lvl] = [];
    saveState();
    return state.queue.shift();
  }
  state.queue = buildQueueForLevel(lvl);
  return state.queue.shift();
}

function nextQuestion(){
  const lvl = state.currentLevel;
  const inf = takeNextInf();
  const v = getVerb(inf);

  state.current = v;
  state.answered = false;

  updateSpeakButton(v);

  clearAnswers();
  setFeedback("");
  setNextEnabled(false);

  els.levelTitle.textContent = UI[getLang()].level(lvl);
  els.qTotal.textContent = DEFAULT_VERBS.length;
  els.qIndex.textContent = countMastered(lvl) + 1;

  if(lvl===1) return buildLevel1(v);
  if(lvl===2) return buildLevel2(v);
  if(lvl===3) return buildLevel3(v);
  if(lvl===4) return buildLevel4(v);
  if(lvl===5) return buildLevel5(v);
  if(lvl===6) return buildLevel6(v);
}

function buildLevel1(v){
  els.questionText.textContent = v.inf;
  els.questionHint.textContent = UI[getLang()].hintL1;
  const pool = DEFAULT_VERBS.map(x=>meaningForLang(x));
  const correct = meaningForLang(v);
  const options = [correct, ...shuffle(pool.filter(x=>x!==correct)).slice(0,2)];
  renderMCQ(options, correct, ()=>{ state.progress[1].mastered[v.inf]=true; saveState(); updateStatsUI(); });
}
function buildLevel2(v){
  els.questionText.textContent = meaningForLang(v);
  els.questionHint.textContent = UI[getLang()].hintL2;
  const pool = allInfs();
  const correct = v.inf;
  const options = [correct, ...shuffle(pool.filter(x=>x!==correct)).slice(0,2)];
  renderMCQ(options, correct, ()=>{ state.progress[2].mastered[v.inf]=true; saveState(); updateStatsUI(); });
}
function buildLevel3(v){
  // Verb en llengua seleccionada -> completa el verb en anglÃ¨s amb lletres
  const target = String(v.inf || "").toLowerCase();
  const letters = target.split("");

  els.questionText.textContent = meaningForLang(v) || v.inf;
  els.questionHint.textContent = UI[getLang()].hintL3;

  els.level3Letters.classList.remove("hidden");
  els.level6Area.classList.add("hidden");
  els.answers.innerHTML = "";

  // Controls N3
  const btnHelp = document.getElementById("btnL3Help");
  const btnSpeak = document.getElementById("btnL3Speak");
  btnSpeak.disabled = true;
  btnSpeak.classList.add("opacity-50","cursor-not-allowed");
  btnSpeak.onclick = null;

  const maxHelp = Math.max(1, Math.min(5, letters.filter(ch=>ch!=="-").length - 3));
  let helpUsed = 0;

  els.letterSlots.innerHTML = "";
  els.letterBank.innerHTML = "";

  const slotEls = [];
  const filled = letters.map(ch => ch === "-" ? true : false);

  // crea slots
  letters.forEach(ch=>{
    const slot = document.createElement("div");
    slot.className = "w-9 h-10 rounded-lg border bg-slate-50 flex items-center justify-center text-lg font-bold";
    slot.textContent = (ch === "-") ? "-" : "";
    slotEls.push(slot);
    els.letterSlots.appendChild(slot);
  });

  function completeCheck(){
    return filled.every(Boolean);
  }

  function placeLetter(ch){
    // troba una posiciÃ³ correcta no omplerta per aquesta lletra
    const positions = [];
    for(let i=0;i<letters.length;i++){
      if(!filled[i] && letters[i]===ch) positions.push(i);
    }
    if(!positions.length) return false;
    const i = positions[0]; // primera posiciÃ³ disponible
    filled[i] = true;
    slotEls[i].textContent = ch.toUpperCase();
    slotEls[i].classList.add("bg-emerald-50","border-emerald-300");
    return true;
  }

  function onSolved(){
    setFeedback(UI[getLang()].correct, true);
    setNextEnabled(true);
    state.progress[3].mastered[v.inf]=true;
    saveState(); updateStatsUI();
    // activa Ã udio
    if(canSpeak()){
      btnSpeak.disabled = false;
      btnSpeak.classList.remove("opacity-50","cursor-not-allowed");
      btnSpeak.onclick = ()=> speakEN(v.inf);
      if(state.audioMode==="auto"){
        // un petit delay perquÃ¨ es vegi el final
        setTimeout(()=>speakEN(v.inf), 150);
      }
    }
  }

  // pool de lletres: lletres del verb + extres
  const alphabet = "abcdefghijklmnopqrstuvwxyz";
  const base = letters.filter(ch=>ch !== "-");
  const extraCount = Math.max(6, Math.min(12, base.length));
  const extras = [];
  while(extras.length < extraCount){
    const c = alphabet[Math.floor(Math.random()*alphabet.length)];
    if(!extras.includes(c)) extras.push(c);
  }
  let pool = base.concat(extras);
  pool = shuffle(pool);

  function markWrong(btn){
    // X vermella centrada
    const x = document.createElement("div");
    x.textContent = "âœ–";
    x.className = "text-red-600 font-black";
    x.style.position="absolute";
    x.style.left="50%";
    x.style.top="50%";
    x.style.transform="translate(-50%,-50%)";
    x.style.fontSize="1.6rem";
    x.style.lineHeight="1";
    x.style.pointerEvents="none";
    btn.appendChild(x);

    state.progress[state.currentLevel].wrong += 1;
    saveState(); updateStatsUI();

    btn.classList.add("shake");
    setTimeout(()=>btn.classList.remove("shake"), 300);
  }

  function checkSolved(){
    if(completeCheck()){
      onSolved();
    }
  }

  // crea banc de lletres
  pool.forEach(ch=>{
    const b = document.createElement("button");
    b.type="button";
    b.className = "relative w-11 h-11 rounded-lg border bg-white hover:bg-slate-50 text-lg font-bold";
    b.textContent = ch.toUpperCase();

    b.addEventListener("click", ()=>{
      if(state.answered) return;
      // si Ã©s correcte, la posa automÃ ticament al seu lloc
      const ok = placeLetter(ch);
      if(ok){
        b.disabled = true;
        b.classList.add("opacity-40","cursor-not-allowed");
        // quan omplim una lletra, incrementem correctes "virtuals" nomÃ©s quan es resol (a dalt ja ho marquem com mastered)
        checkSolved();
      }else{
        if(b.disabled) return;
        b.disabled = true;
        b.classList.add("opacity-40","cursor-not-allowed");
        markWrong(b);
      }
    });

    els.letterBank.appendChild(b);
  });

  // Ajuda: posa lletres correctes (fins al lÃ­mit)
  btnHelp.onclick = ()=>{
    if(state.answered) return;
    if(helpUsed >= maxHelp) return;
    // posicions encara buides (no guiÃ³)
    const remaining = [];
    for(let i=0;i<letters.length;i++){
      if(!filled[i] && letters[i] !== "-") remaining.push(i);
    }
    if(!remaining.length) return;
    // tria una posiciÃ³ aleatÃ²ria i omple
    const i = remaining[Math.floor(Math.random()*remaining.length)];
    const ch = letters[i];
    if(placeLetter(ch)){
      helpUsed++;
      // desactiva una lletra del banc (la primera coincident activa)
      const bankBtns = Array.from(els.letterBank.querySelectorAll("button"));
      const btn = bankBtns.find(b=>!b.disabled && b.textContent.toLowerCase()===ch);
      if(btn){
        btn.disabled = true;
        btn.classList.add("opacity-40","cursor-not-allowed");
      }
      if(helpUsed >= maxHelp){
        btnHelp.disabled = true;
        btnHelp.classList.add("opacity-50","cursor-not-allowed");
      }
      checkSolved();
    }
  };

  // estat inicial
  state.answered = false;
  btnHelp.disabled = false;
  btnHelp.classList.remove("opacity-50","cursor-not-allowed");
  setFeedback("", true);
  setNextEnabled(false);
  updateStatsUI();

  // Ã€udio automÃ tic: quan es mostra el nivell 3, encara no hi ha verb EN visible; no fem res.
}

function buildLevel4(v){
  els.questionText.textContent = `${v.inf} (${v.ca || ""})`.replace(/\s+\(\s*\)$/, "");
  els.questionHint.textContent = UI[getLang()].hintL4;
  const { options, correct } = makeLevel3Options(v);
  renderMCQ(options, correct, ()=>{ state.progress[3].mastered[v.inf]=true; saveState(); updateStatsUI(); });
}

function buildLevel5(v){
  els.questionText.textContent = `${v.inf} (${v.ca || ""})`.replace(/\s+\(\s*\)$/, "");
  els.questionHint.textContent = UI[getLang()].hintL5;
  const { options, correct } = makeLevel4Options(v);
  renderMCQ(options, correct, ()=>{ state.progress[4].mastered[v.inf]=true; saveState(); updateStatsUI(); });
}

function buildLevel6(v){
  els.questionText.textContent = meaningForLang(v) || v.inf;
  els.questionHint.innerHTML = UI[getLang()].hintL6;
  els.level6Area.classList.remove("hidden");

  const pool = makeLevel5Pool(v); // 5 options (mateixes als 3 selectors)

  fillSelect(els.selInf, shuffle(pool));
  fillSelect(els.selPast, shuffle(pool));
  fillSelect(els.selPP, shuffle(pool));

  els.selInf.value=""; els.selPast.value=""; els.selPP.value="";

  // Next sempre desactivat fins encertar
  setNextEnabled(false);

  // helpers visuals
  const wrapInf = els.selInf.closest(".bg-white");
  const wrapPast = els.selPast.closest(".bg-white");
  const wrapPP = els.selPP.closest(".bg-white");

  function clearWrap(w){
    if(!w) return;
    w.classList.remove("bg-green-100","border-green-500","bg-red-100","border-red-500");
    w.classList.add("bg-white");
  }
  function setWrap(w, ok){
    if(!w) return;
    w.classList.remove("bg-white","bg-green-100","border-green-500","bg-red-100","border-red-500");
    if(ok===null){
      w.classList.add("bg-white");
    } else if(ok){
      w.classList.add("bg-green-100","border-green-500");
    } else {
      w.classList.add("bg-red-100","border-red-500");
    }
  }

  // reset visuals when user changes a selector
  [els.selInf, els.selPast, els.selPP].forEach(sel=>{
    sel.addEventListener("change", ()=>{
      // nomÃ©s netegem el seu wrap (per no perdre feedback dels altres)
      if(sel===els.selInf) setWrap(wrapInf, null);
      if(sel===els.selPast) setWrap(wrapPast, null);
      if(sel===els.selPP) setWrap(wrapPP, null);
      setFeedback("", true);
    }, { once:false });
  });

  els.btnCheckLevel6.onclick = ()=>{
    const a=els.selInf.value, b=els.selPast.value, c=els.selPP.value;
    if(!a||!b||!c){
      setFeedback(UI[getLang()].needAllSelects, false);
      wiggle();
      return;
    }

    const okInf = (a===v.inf);
    const okPast = (b===v.past);
    const okPP = (c===v.pp);

    setWrap(wrapInf, okInf);
    setWrap(wrapPast, okPast);
    setWrap(wrapPP, okPP);

    const allOk = okInf && okPast && okPP;

    if(allOk){
      // ara sÃ­: marquem com complet i deixem avanÃ§ar
      state.answered = true;
      state.progress[5].correct += 1;
      state.progress[5].mastered[v.inf]=true;

      setFeedback(UI[getLang()].lvl6Good, true);
      saveState(); updateStatsUI();
      setNextEnabled(true);
      maybeFinishLevel();
    } else {
      // permet reintentar tantes vegades com calgui
      state.answered = false;
      state.progress[5].wrong += 1;
      setFeedback(UI[getLang()].stillNot, false);
      saveState(); updateStatsUI();
      setNextEnabled(false);
      wiggle();
    }
  };

  updateStatsUI();
}


function fillSelect(sel, options){
  sel.innerHTML = `<option value="">â€” selecciona â€”</option>` +
    options.map(o=>`<option value="${o}">${o}</option>`).join("");
}



function startLevel(lvl){
  if(!isLevelUnlocked(lvl)){
    setFeedback(UI[getLang()].lockedLevel, false);
    return;
  }
  state.currentLevel = lvl;
  state.queue = buildQueueForLevel(lvl);
  state.retries[lvl] = [];
  state.current = null;
  state.answered = false;
  saveState(); updateStatsUI();
  nextQuestion();
  updateSpeakButton(state.current);
}


// Language selector
(function initControls(){
  // Language
  const sel = document.getElementById("langSel");
  if(sel){
    const current = getLang();
    sel.value = current;
    sel.addEventListener("change", ()=>{
      setLang(sel.value);
      applyLanguage();
    });
  }

  // Audio mode
  if(els.audioModeSel){
    els.audioModeSel.value = state.audioMode || "manual";
    els.audioModeSel.addEventListener("change", ()=>{
      state.audioMode = els.audioModeSel.value;
      saveState();
      // If auto, speak what's visible now
      if(state.audioMode==="auto") setTimeout(()=>speakAutoForCurrent(), 120);
    });
  }

  // Only marked
  if(els.chkOnlyMarked){
    els.chkOnlyMarked.checked = !!state.onlyMarked;
    els.chkOnlyMarked.addEventListener("change", ()=>{
      state.onlyMarked = !!els.chkOnlyMarked.checked;
      // rebuild queue for current level but keep current verb if possible
      state.queue = buildQueueForLevel(state.currentLevel);
      saveState();
      updateStatsUI();
    });
  }
})();
els.levelBar.addEventListener("click", (e)=>{
  const btn = e.target.closest("button[data-level]");
  if(!btn) return;
  const lvl = parseInt(btn.dataset.level,10);
  if(lvl === state.currentLevel) return;
  startLevel(lvl);
});
els.btnNext.addEventListener("click", ()=>{
  if(els.btnNext.disabled) return;
  nextQuestion();
  updateSpeakButton(state.current);
});


function openVerbList(){
  const rows = DEFAULT_VERBS.map(v=>{
    const ca = meaningForLang(v) || v.inf;
    const inf=v.inf, past=v.past, pp=v.pp;
    const eqAll = (inf===past && past===pp);
    const eqInfPast = (inf===past && past!==pp);
    const eqInfPP = (inf===pp && inf!==past);
    const eqPastPP = (past===pp && past!==inf);

    function cellClass(kind){
      // kind: 'inf'|'past'|'pp'
      // color scheme:
      // - all equal: green for all three
      // - exactly two equal: amber for the matching pair, third neutral
      // - all different: slate for all three (same)
      if(eqAll) return "bg-emerald-100";
      if(eqInfPast){
        if(kind==="inf"||kind==="past") return "bg-yellow-100";
        return "bg-yellow-50";
      }
      if(eqInfPP){
        if(kind==="inf"||kind==="pp") return "bg-yellow-100";
        return "bg-yellow-50";
      }
      if(eqPastPP){
        if(kind==="past"||kind==="pp") return "bg-yellow-100";
        return "bg-yellow-50";
      }
      return "bg-orange-200";
    }

    return `<tr class="border-b">
      <td class="px-3 py-2 font-mono ${cellClass("inf")}">${inf}</td>
      <td class="px-3 py-2 font-mono ${cellClass("past")}">${past}</td>
      <td class="px-3 py-2 font-mono ${cellClass("pp")}">${pp}</td>
      <td class="px-3 py-2">${ca}</td>
    </tr>`;
  }).join("");

  const page = `<!DOCTYPE html>
  <html lang="ca"><head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Llista de verbs irregulars</title>
    <script src="https://cdn.tailwindcss.com"><\/script>
  </head>
  <body class="bg-slate-50 text-slate-800 p-4">
    <div class="max-w-5xl mx-auto bg-white rounded-2xl shadow p-4 sm:p-6">
      <div class="flex flex-col sm:flex-row sm:items-end sm:justify-between gap-3">
        <div>
          <h1 class="text-2xl font-bold">${UI[getLang()].listTitle}</h1>
          <p class="text-sm text-slate-500 mt-1">${UI[getLang()].listSubtitle}</p>
          <p class="text-xs text-slate-500 mt-1">
            ${UI[getLang()].colors.label} <span class="inline-block px-2 py-0.5 rounded bg-emerald-200">${UI[getLang()].colors.easy}</span>
            <span class="inline-block px-2 py-0.5 rounded bg-yellow-200 ml-1">${UI[getLang()].colors.mid}</span>
            <span class="inline-block px-2 py-0.5 rounded bg-orange-100 ml-1">${UI[getLang()].colors.hard}</span>
          </p>
        </div>
        <div class="flex gap-2">
          <input id="q" class="border rounded-lg px-3 py-2 w-full sm:w-72" placeholder="${UI[getLang()].searchPh}" />
          <button id="btnClose" class="bg-slate-200 hover:bg-slate-300 rounded-lg px-3 py-2 font-bold">${UI[getLang()].close}</button>
        </div>
      </div>

      <div class="mt-4 overflow-auto rounded-xl border">
        <div class="overflow-x-auto -mx-3 px-3 pb-3"><table class="min-w-full text-sm">
          <thead class="sticky top-0 bg-slate-100 z-10">
            <tr class="text-left">
              <th class="px-3 py-2">Infinitive</th>
              <th class="px-3 py-2">Simple Past</th>
              <th class="px-3 py-2">Past Participle</th>
              <th class="px-3 py-2">${UI[getLang()].meaningHeader}</th>
            </tr>
          </thead>
          <tbody id="tbody">${rows}</tbody>
        </table></div>
      </div>
    </div>

    <script>
      const q = document.getElementById("q");
      const tbody = document.getElementById("tbody");
      const allRows = Array.from(tbody.querySelectorAll("tr"));
      function norm(s){ return (s||"").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,""); }
      q.addEventListener("input", ()=>{
        const term = norm(q.value);
        allRows.forEach(r=>{
          const txt = norm(r.textContent);
          r.style.display = (!term || txt.includes(term)) ? "" : "none";
        });
      });
      document.getElementById("btnClose").addEventListener("click", ()=> window.close());
    <\/script>
  </body></html>`;

  const w = window.open("", "_blank");
  if(!w){
    openModal("No s'ha pogut obrir", "<p>El navegador ha bloquejat la finestra emergent. Permet pop-ups per aquest fitxer i torna-ho a provar.</p>");
    return;
  }
  w.document.open();
  w.document.write(page);
  w.document.close();
}

els.btnList.addEventListener("click", openVerbList);

els.btnHelp.addEventListener("click", ()=>{ openModal(UI[getLang()].helpTitle, UI[getLang()].helpBody); });
els.btnReset.addEventListener("click", ()=>{
  openModal("Reiniciar progrÃ©s", `
    <p>Vols reiniciar tot el progrÃ©s?</p>
    <p class="mt-2 text-slate-600">AixÃ² no es pot desfer.</p>
    <div class="mt-4 flex gap-2 justify-end">
      <button id="confirmReset" class="bg-red-600 text-white font-bold px-4 py-2 rounded hover:bg-red-700 transition">SÃ­, reinicia</button>
    </div>
  `);
  setTimeout(()=>{
    const btn=document.getElementById("confirmReset");
    if(btn) btn.onclick = ()=>{
      localStorage.removeItem(STORE_KEY);
      state = initialState();
      saveState();
      closeModal();
      updateStatsUI();
      clearAnswers();
      els.questionText.textContent = UI[getLang()].selectLevelToStart;
      els.questionHint.textContent = "";
      els.qIndex.textContent="â€”"; els.qTotal.textContent="â€”";
      setFeedback("");
      setNextEnabled(false);
    };
  },0);
});

updateStatsUI();
updateLevelButtons();
setNextEnabled(false);
</script>
</body>
</html>
