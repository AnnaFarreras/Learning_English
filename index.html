
<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Joc verbs irregulars (anglÃ¨s)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
  .hidden{display:none !important;}
.optRow{
  display:flex;
  align-items:stretch;
  gap:.6rem;
  margin-bottom:.75rem;
}
.optAudio{
  width:32px;
  min-width:32px;
  height:32px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border-radius:0.5rem;
  font-size:0.9rem;
  padding:0;
  border:1px solid rgba(15,23,42,.18);
  background:rgba(226,232,240,.9);
  opacity:.55;
  align-self:center;
}



    .card { box-shadow: 0 10px 25px rgba(0,0,0,.08); }
    .btn-disabled { opacity:.55; pointer-events:none; }
    .shake { animation: shake .3s; }
    @keyframes shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-6px); }
      50% { transform: translateX(6px); }
      75% { transform: translateX(-6px); }
      100% { transform: translateX(0); }
    }

    /* Options: keep color even on hover */
    .optBtn { transition: background-color .15s, border-color .15s, transform .08s; }
    .optBtn:hover { background-color: rgb(241 245 249); } /* slate-100 */
    .optLocked:hover { background-color: inherit !important; }
    .optCorrect { background-color: rgb(134 239 172) !important; border-color: rgb(22 163 74) !important; }
    .optWrong { background-color: rgb(252 165 165) !important; border-color: rgb(220 38 38) !important; }
    .optReveal { background-color: rgb(134 239 172) !important; border-color: rgb(22 163 74) !important; }
  
      table{min-width:720px;}
      @media (max-width:480px){
        body{padding:12px !important;}
        h1{font-size:28px !important;}
        th,td{font-size:14px;}
      }
    
    /* Active level button: bigger + 3D */
    .levelBtn { position: relative; }
    .levelBtn.level-active{
      transform: translateY(-1px) scale(1.12);
      box-shadow: 0 10px 16px rgba(0,0,0,.18);
      filter: brightness(1.03);
      z-index: 5;
    }
    .levelBtn.level-active::after{
      content:"";
      position:absolute; inset:0;
      border-radius:0.5rem;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.35), inset 0 -2px 0 rgba(0,0,0,.18);
      pointer-events:none;
    }
    @media (prefers-reduced-motion: reduce){
      .levelBtn.level-active{ transform:none; }
    }

  
    #btnHelp, #btnList{ white-space:nowrap; }

    /* Top action buttons: keep on one line and equal width (auto) */
#btnHelp, #btnList{
  white-space: nowrap;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: auto;
  min-width: unset !important;
}
/* Make level title visible but not stronger than the verb */
#levelTitle{
  font-weight: 600; /* bold, not black */
  font-size: 1.05rem;
  color: #0f172a;
}



  /* Level 3 tense filters */
  #tenseFilters .tenseChk{ width:14px; height:14px; }
  #tenseFilters label{ white-space:nowrap; }


    /* Level 3 tense filters (right side) */
    #tenseFilters{ justify-self:end; align-self:start;  grid-column:3; grid-row:2; }
    @media (min-width: 641px){
  #tenseFilters .tenseBox{ width: max-content; }
}

  :root{--sideBtnW:160px;}
  #btnHelp,#btnList{width:var(--sideBtnW); white-space:nowrap; text-align:center;}
  #btnStats{width:auto; min-width:unset;}

/* --- Layout polish: keep start message & verb on one line when possible (responsive) --- */
#questionText{
  text-align:center;
  line-height:1.15;
  max-width:100%;
  word-break:normal;
  overflow-wrap:normal;
}
@media (min-width: 640px){
  #questionText{
    white-space:nowrap; /* one line on tablet/desktop when space allows */
  }
}
@media (max-width: 639px){
  #questionText{
    white-space:normal; /* allow wrapping on mobile */
  }
}


    /* --- fixes: visibility + header layout --- */
    #questionHint{margin:4px 0 3px 0;}

    
    
    .quizHeaderGrid.noLevel{grid-template-columns:1fr; justify-items:center;}
.quizHeaderGrid{
      display:grid;
      grid-template-columns:auto 1fr auto;
      align-items:start;
      gap:12px;
    }
    /* Always keep the center text centered within its column */
    #questionText{ text-align:center; justify-self:center; }
    /* When no level selected: only show the center area, fully centered */
    .no-level #quizHeaderGrid{
      grid-template-columns:1fr;
      justify-items:center;
    }
    .no-level #questionText{width:100%; text-align:center;}
    .no-level #levelHeaderLeft,
    .no-level #tenseFilters{ display:none!important; }
    /* Tense filters: vertical box top-right */
    .tenseFilters{ justify-self:end; align-self:start; }
    .tenseBox{ display:flex; flex-direction:column; gap:6px; }
    @media (max-width: 520px){
      /* on very small screens, let the verb wrap and avoid pushing filters down */
      #questionText{ white-space:normal; overflow-wrap:anywhere; }
      .quizHeaderGrid{ grid-template-columns:auto 1fr auto; }

      /* Level 3: keep tense selectors on ONE centered row under reset buttons */
      
      
}

  
/* N3: tense label smaller */
.tenseSmall{ font-size:0.75em; font-weight:600; opacity:0.85; }
/* Small square icon buttons */
.iconBtn{
  width:40px; height:40px;
  border-radius:12px;
  border:1px solid rgba(148,163,184,.6);
  background:#fff;
  display:flex; align-items:center; justify-content:center;
  font-weight:800;
}
.iconBtn:disabled{ opacity:.45; cursor:not-allowed; }


  .starBtn{
    border:0;
    background:transparent;
    font-size:20px;
    line-height:1;
    padding:2px 4px;
    border-radius:8px;
    cursor:pointer;
  }
  .starBtn:hover{ background: rgba(148,163,184,.25); }
  .starBtn[aria-pressed="false"]{ opacity:.55; }
  .rightPanel{ display:flex; flex-direction:column; align-items:flex-end; gap:10px; }
  .studyControls{
    background: rgba(255,255,255,.6);
    border:1px solid #e2e8f0;
    border-radius: 12px;
    padding: 8px 10px;
    display:flex;
    flex-direction:column;
    gap:6px;
    align-items:flex-start;
  }
  .miniResetStars{
    background:#ef4444;
    color:#fff;
    border:0;
    border-radius:999px;
    padding:4px 10px;
    font-size:12px;
    font-weight:600;
    cursor:pointer;
  }
  .miniResetStars:disabled{ opacity:.45; cursor:not-allowed; }

  .starToggle{ border:0; background:transparent; font-size:18px; line-height:1; padding:2px 4px; border-radius:8px; cursor:pointer; }
  .starToggle:hover{ background: rgba(148,163,184,.25); }

    /* Hide star button when no level selected */
    .no-level #btnStar{display:none!important;}

/* FIX20: compact level 3 spacing */
#level3Letters{ margin-top: .25rem !important; }
#level3Letters .bg-white{ padding: .6rem !important; }
#letterBank{ margin-top: .4rem !important; }


/* FIX23: Level 3 - hide top speak button + compact vertical spacing so progress bar stays visible */
body.lvl3 #btnSpeak{ display:none !important; }
body.lvl3 #quizArea{ padding: 0.9rem !important; }
body.lvl3 #questionHint{ margin-top: .25rem !important; margin-bottom: .25rem !important; }
body.lvl3 #level3Letters{ margin-top: .25rem !important; }
body.lvl3 #level3Letters .bg-white{ padding: .55rem !important; }
body.lvl3 #level3Letters .mt-2{ margin-top: .4rem !important; }
body.lvl3 #letterBank{ gap: .35rem !important; }
body.lvl3 #quizFooter{ margin-top: .5rem !important; }
body.lvl3 #progressSection{ margin-top: .6rem !important; }


/* FIX24: prevent stray (unwired) audio buttons inside question text */
#questionText button{ display:none !important; }

/* FIX26: Hide top speak button on levels where the question is NOT English (N2, N3, N6) */
body.lvl2 #btnSpeak, body.lvl3 #btnSpeak, body.lvl6 #btnSpeak{ display:none !important; }

/* FIX60: Ensure audio button is always visible on mobile for levels 1, 4, 5 */
@media (max-width: 640px){
  body.lvl1 #btnSpeak, body.lvl4 #btnSpeak, body.lvl5 #btnSpeak{ 
    display:flex !important; 
    visibility:visible !important;
    opacity:1 !important;
  }
}


.optRow .mcqBtn{
  flex:1 1 auto;
}
.optRow 
.optRow .optAudio:disabled{
  cursor:not-allowed;
}
.optRow .optAudio.optAudioOn{
  opacity:1;
}



.optRow .mcqBtn{ flex:1 1 auto; }
.optRow 
.optRow .optAudio.optAudioOn{ opacity:1; }


/* FIX34: Adjacent audio icon rows (only used in N2/N4/N5) */

.optRow .optBtn{ flex:1 1 auto; }
.optRow 
.optRow .optAudio.optAudioOn{ opacity:1; }


/* FIX36: Smaller, consistent audio icons for N2/N4/N5 options */
.optRow 
.optRow .optAudio svg,
.optRow .optAudio span{
  transform: scale(0.9);
}


/* FIX38: center audio buttons in rows */
.optRow 

/* FIX41: place audio mode selector on the left side of header */
.audioModeSel{
  margin-right:auto;
}



/* FIX48: Level 3 tense filters under level title, not in right panel */
.lvl3HeaderCol{ flex-direction:column; align-items:flex-start; gap:.25rem; }
.lvl3HeaderCol #tenseFilters{ margin:0; }
.lvl3HeaderCol #tenseFilters .tenseBox{ box-shadow:none; }


/* FIX51: In level 3, left header stack vertically so tense filters sit BELOW title row */
.lvl3LeftCol{ display:flex; flex-direction:column; align-items:flex-start; gap:.5rem; }
#lvlTopRow{ display:flex; align-items:center; gap:.75rem; }

/* MÃ²bil: tÃ­tol i botÃ³ apilats al Nivell 3 */
@media (max-width: 640px){
  body.lvl3 #levelHeaderLeft #lvlTopRow{
    display: flex !important;
    flex-direction: column !important;
    align-items: flex-start !important;
    gap: 0.4rem !important;
  }
}

/* ===== Header responsive fix (mobile first open) ===== */
/* Give the title padding on BOTH sides to avoid overlapping absolute selectors */
#appTitle { padding-left: 7rem; padding-right: 7rem; }

/* On small screens, convert the header to a grid so selectors stay on top row
   and the title drops below them (no overlap). */


/* On larger screens, keep normal flow; let Tailwind handle sizes */
@media (min-width: 481px){
  #appTitle { white-space: nowrap; }
}


/* ===== HEADER: on small screens put title UNDER selectors ===== */
@media (max-width: 520px) {
  header.mb-3.relative{
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-areas:
      "audio lang"
      "title title"
      "sub sub";
    column-gap: 12px;
    row-gap: 10px;
    align-items: center;
  }
  header.mb-3.relative > div.absolute.left-0.top-0{
    grid-area: audio;
    position: static !important;
    justify-self: start;
  }
  header.mb-3.relative > div.absolute.right-0.top-0{
    grid-area: lang;
    position: static !important;
    justify-self: end;
  }
  header.mb-3.relative > h1#appTitle{
    grid-area: title;
    padding-left: 0 !important;
    padding-right: 0 !important;
    margin-top: 2px;
  }
  header.mb-3.relative > p#appSubtitle{
    grid-area: sub;
    margin-top: 0 !important;
  }
}

/* ===== QUIZ HEADER: Mobile layout (keep desktop unchanged) =====
   Goal on small screens:
   - Left: "Nivell X" with "Reinicia" UNDER it (left aligned)
   - Right: "NomÃ©s â­" on one line, and "Reinicia â­" UNDER it (right aligned)
   - Center: if there is audio (ğŸ”Š), it sits centered on its own line ABOVE the verb line
            then â­ + verb centered together; if verb has extra text (e.g., in parentheses)
            it can wrap to next line naturally.
*/
@media (max-width: 640px){
  .quizHeaderGrid{
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    grid-template-areas:
      "left right"
      "center center"
      "tense tense" !important;
    gap: 0.75rem !important;
    align-items: start !important;
  }
  /* Left block: title + reset stacked, aligned left */
  #levelHeaderLeft{
    grid-area: left !important;
    display: flex !important;
    flex-direction: column !important;
    align-items: flex-start !important;
    gap: 0.4rem !important;
    min-width: 0;
  }
  #btnReset{
    align-self: flex-start !important;
  }
  /* Right block: study controls stay top-right */
  #rightPanel{
    grid-area: right !important;
    width: auto !important;
    display: flex !important;
    flex-direction: column !important;
    align-items: flex-end !important;
    justify-content: flex-start !important;
    gap: 0.35rem !important;
  }
  
  #studyControls{
    width: auto !important;
    align-items: flex-end !important;
  }
  
  #studyControls label{
    display: inline-flex !important;
    align-items: center !important;
    gap: 0.35rem !important;
    justify-content: flex-end !important;
    white-space: nowrap;
  }
  
  #btnResetStars{
    align-self: flex-end !important;
  }
  /* Center block: ALWAYS below left+right (prevents long verbs being cut) */
  #questionCenter{
    grid-area: center !important;
    width: 100% !important;
    justify-self: stretch !important;
    display: flex !important;
    flex-wrap: wrap !important;
    align-items: center !important;
    justify-content: center !important;
    gap: 0.5rem !important;
    padding-top: 0.1rem;
    min-width: 0;
  }
  
  #btnSpeak{
    order: 0 !important;
    flex-shrink: 0 !important;
  }
  
  #btnStar{
    order: 1 !important;
    flex-shrink: 0 !important;
  }
  
  #questionText{
    order: 2 !important;
    text-align: center !important;
    justify-self: stretch !important;
    word-break: break-word;
    overflow-wrap: anywhere;
    line-height: 1.15;
    flex-shrink: 1 !important;
  }
  /* If audio is hidden in a level, collapse the audio row */
  #btnSpeak
  
  /* Tense filters (general): below center, centered */
#tenseFilters{
  grid-area: tense !important;
  justify-self: stretch !important;
  align-self: stretch !important;
  width: 100% !important;
  max-width: 100% !important;
  display: flex !important;
  justify-content: center !important;
}
  
  /* NIVELL 3: Canviar ordre - selectors ABANS del verb */
body.lvl3 #quizHeaderGrid{
  grid-template-columns: 1fr 1fr !important;
  grid-template-areas:
    "left right"
    "left right"
    "tense tense"
    "center center" !important;
  gap: 0.5rem !important;
}

body.lvl3 #levelHeaderLeft{
  grid-area: left !important;
  display: flex !important;
  flex-direction: column !important;
  gap: 0.4rem !important;
  width: 100% !important;
  justify-self: stretch !important;
  align-self: stretch !important;
}

body.lvl3 #rightPanel{
  grid-area: right !important;
  display: flex !important;
  flex-direction: column !important;
  gap: 0.4rem !important;
}

body.lvl3 #tenseFilters{
  grid-area: tense !important;
  grid-column: 1 / -1 !important;
  justify-self: stretch !important;
  width: 100% !important;
  margin-top: 0.5rem !important;
  display: block !important;
}


#tenseFilters .tenseBox{
  width: 100% !important;
  max-width: 100% !important;
  min-width: 0 !important;
  box-sizing: border-box !important;
  display: grid !important;
  grid-template-columns: repeat(3, 1fr) !important;
  align-items: center !important;
  justify-items: center !important;
  margin: 0 auto !important;
}

#tenseFilters .tenseBox label{
  margin: 0 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: .35rem !important;
  white-space: nowrap !important;
}


body.lvl3 #questionCenter{
  grid-area: center !important;
  margin-top: 0.5rem !important;
}
  
/* --- Pregunta: mantenir ğŸ”Š + â­ + VERB junts i el text entre parÃ¨ntesis a sota --- */
  #questionCenter{
    display:flex !important;
    flex-wrap: wrap !important;
    align-items: center !important;
    justify-content: center !important;
    gap: .5rem !important;
  }

  /* Els botons no han de "estirar-se" */
  #btnSpeak, #btnStar{ flex: 0 0 auto !important; }

  /* Convertim el contenidor de text en "contents" perquÃ¨ els spans siguin items del flex */
  #questionText{
    display: contents !important;
  }

  /* Verb principal */
  #questionText .qMain{
    flex: 0 1 auto !important;
    min-width: 0 !important;
    font-size: 1.35rem !important;
    font-weight: 700;
    text-align: center !important;
    line-height: 1.15;
    word-break: break-word;
    overflow-wrap: anywhere;
  }

  /* ParÃ¨ntesis (significat/tense) sempre a la lÃ­nia de sota */
  #questionText .qParen{
    flex: 0 1 auto !important;          /* queda a la mateixa lÃ­nia si hi cap */
    max-width: 100% !important;
    display: inline-block !important;
    text-align: center !important;
    margin-left: .15rem !important;
    white-space: nowrap !important;      /* mantÃ© el parÃ¨ntesi junt */
  }

/* Si ğŸ”Š estÃ  amagat en algun nivell */
  #btnSpeak
/* --- Nivell 6: compactar (label + select a la mateixa lÃ­nia) --- */
  body.lvl6 #level6Area .grid > div{
    display:flex !important;
    flex-direction: row !important;
    align-items: center !important;
    gap: .75rem !important;
    padding-top: .6rem !important;
    padding-bottom: .6rem !important;
  }
  body.lvl6 #level6Area .grid > div > div.text-xs{
    margin: 0 !important;
    min-width: 72px !important;   /* etiqueta curta (Inf / Past / PP) */
    white-space: nowrap !important;
  }
  body.lvl6 #level6Area .grid > div > div.flex{
    flex: 1 1 auto !important;
    min-width: 0 !important;
  }
  body.lvl6 #level6Area select{
    width: 100% !important;
  }
}
/* FIX: Level 3 tense filters - full width and centered on mobile */
@media (max-width: 640px) {
  body.lvl3 #tenseFilters {
    grid-area: tense !important;
    justify-self: stretch !important;
    align-self: stretch !important;
    width: 100% !important;
    max-width: 100% !important;
    display: flex !important;
    justify-content: center !important;
    padding: 0 !important;
    margin: 0 !important;
  }
  
  #tenseFilters .tenseBox {
    width: 100% !important;
    max-width: 100% !important;
    min-width: 0 !important;
    box-sizing: border-box !important;
    display: grid !important;
    grid-template-columns: repeat(3, 1fr) !important;
    align-items: center !important;
    justify-items: center !important;
    gap: 0.5rem !important;
    padding: 0.5rem !important;
    margin: 0 !important;
  }
  
  #tenseFilters .tenseBox label {
    width: 100% !important;
    margin: 0 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    gap: .35rem !important;
    white-space: nowrap !important;
  }
}
</style>
</head>
<body class="bg-slate-50 text-slate-800 min-h-screen p-3 sm:p-4">
<div id="app" class="max-w-3xl mx-auto bg-white rounded-2xl card p-4 sm:p-6">
    <header class="mb-3 relative">
      <div class="absolute left-0 top-0">
        <select id="audioModeSel" class="audioModeSel border border-slate-200 rounded-xl px-3 py-2 bg-white text-sm">
  <option value="auto">ğŸ”Š Auto</option>
  <option value="manual">ğŸ”Š Manual</option>
</select>
      </div>
      <div class="absolute right-0 top-0">
        <select id="langSel" class="border rounded-lg px-3 py-2 bg-white text-sm">
      <option value="ca">CatalÃ </option>
      <option value="es">Castellano</option>
      <option value="ka">áƒ¥áƒáƒ áƒ—áƒ£áƒšáƒ˜</option>
    </select>
      </div>
      <h1 id="appTitle" class="text-xl sm:text-2xl font-bold text-center px-28">Verbs Irregulars anglesos</h1>
      <p id="appSubtitle" class="text-center text-slate-500 mt-1 text-sm">
        6 nivells. No pugis de nivell fins haver encertat tots els verbs almenys 1 cop.
      </p>
    </header>

    <div class="mb-3">
      <div class="flex items-start justify-between gap-2">
        <div id="levelBar" class="flex flex-wrap gap-2 justify-center w-full">
          <button data-level="1" class="levelBtn shrink-0 bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 transition text-sm">N1</button>
          <button data-level="2" class="levelBtn shrink-0 bg-sky-500 text-white px-3 py-1 rounded hover:bg-sky-600 transition text-sm">N2</button>
          <button data-level="3" class="levelBtn shrink-0 bg-teal-500 text-white px-3 py-1 rounded hover:bg-teal-600 transition text-sm">N3</button>
          <button data-level="4" class="levelBtn shrink-0 bg-emerald-500 text-white px-3 py-1 rounded hover:bg-emerald-600 transition text-sm">N4</button>
          <button data-level="5" class="levelBtn shrink-0 bg-amber-500 text-white px-3 py-1 rounded hover:bg-amber-600 transition text-sm">N5</button>
          <button data-level="6" class="levelBtn shrink-0 bg-purple-600 text-white px-3 py-1 rounded hover:bg-purple-700 transition text-sm">N6</button>
          <button id="btnStats" class="shrink-0 bg-slate-200 text-slate-800 font-bold px-3 py-1 rounded hover:bg-slate-300 transition text-sm" title="ğŸ“Š">ğŸ“Š</button>
        </div>
        

        <div class="flex flex-col gap-2 items-end">
<button id="btnHelp" class="bg-slate-200 text-slate-800 font-bold px-2 py-1 rounded hover:bg-slate-300 transition text-xs min-w-[110px] text-center" style="white-space:nowrap; ">Instruccions</button>
<button id="btnList" class="bg-emerald-600 text-white font-bold px-2 py-1 rounded hover:bg-emerald-700 transition text-xs min-w-[110px] text-center" style="white-space:nowrap; ">Llista de verbs</button>
        </div>
      </div>

      <div id="devHint" class="mt-2 hidden text-xs text-slate-500">
        Mode prova actiu: nivells desbloquejats (URL amb <code class="bg-slate-100 px-1 rounded">?dev=1</code>).
      </div>
    </div>

    <div id="quizArea" class="bg-slate-50 rounded-xl p-4 sm:p-6">
      <div id="quizHeaderGrid" class="quizHeaderGrid">
        <div class="flex items-center gap-2" id="levelHeaderLeft">
          <div class="text-sm text-slate-500" id="levelTitle">Nivell 1</div>
          <button id="btnReset" class="bg-red-600 text-white font-bold px-3 py-1 rounded-lg shadow-sm hover:bg-red-700 transition text-xs disabled:opacity-40 disabled:cursor-not-allowed">Reinicia</button>
        </div>

        <div class="flex items-center justify-center gap-2" id="questionCenter">
          <button id="btnStar" class="starBtn" title="â­">â­</button>
          <div class="text-xl sm:text-2xl font-semibold text-center" id="questionText">Selecciona un nivell per comenÃ§ar</div>
          <button id="btnSpeak" title="Escoltar pronunciaciÃ³" class="bg-slate-200 hover:bg-slate-300 rounded px-2 py-1 text-sm">ğŸ”Š</button>
        </div>
        <!-- question hint moved below header for better alignment -->
        
        <div id="rightPanel" class="rightPanel">
        <div id="studyControls" class="hidden studyControls">
          <label class="flex items-center gap-2 text-xs cursor-pointer select-none">
            <input type="checkbox" id="chkFavOnly" />
            <span id="lblFavOnly">NomÃ©s â­</span>
          </label>
          <button id="btnResetStars" class="miniResetStars">Reinicia â­</button>
        </div>
        </div>
        <div id="tenseFilters" class="hidden tenseFilters">
          <div class="tenseBox bg-white/60 border border-slate-200 rounded-lg px-2 py-2 flex flex-col gap-1 items-start">
            <label class="flex items-center gap-1 text-xs cursor-pointer select-none">
              <input id="tenseInf" type="checkbox" class="tenseChk" data-tense="inf">
              <span id="tenseInfLbl">Infinitive</span>
            </label>
            <label class="flex items-center gap-1 text-xs cursor-pointer select-none">
              <input id="tensePast" type="checkbox" class="tenseChk" data-tense="past">
              <span id="tensePastLbl">Simple Past</span>
            </label>
            <label class="flex items-center gap-1 text-xs cursor-pointer select-none">
              <input id="tensePP" type="checkbox" class="tenseChk" data-tense="pp">
              <span id="tensePPLbl">Past Participle</span>
            </label>
          </div>
        </div>
    
      </div>

      <div id="questionHint" class="mt-2 mb-1 text-sm text-slate-500 text-left"></div>

      <div id="answers" class="mt-3 grid grid-cols-1 sm:grid-cols-3 gap-2"></div>



      <!-- Nivell 3: escriu el verb (lletres) -->
      <div id="level3Letters" class="mt-1 hidden">
        <div class="bg-white rounded-xl border p-3">
          <div class="flex items-center justify-between gap-2 mb-1">
            <div class="text-xs text-slate-500">Completa el verb en anglÃ¨s</div>
            <div class="flex items-center gap-2">
              <button id="btnL3Help" class="iconBtn" title="Ajuda">?</button>
            </div>
          </div>
          <div class="flex items-center justify-center gap-3 mt-2">
  <div id="letterSlots" class="flex flex-wrap gap-2 justify-center"></div>
  <button id="btnL3Audio" class="iconBtn" title="Audio" disabled>ğŸ”Š</button>
</div>
          <div class="mt-2 text-sm text-slate-500 text-center"><span id="lblLetterExplain">Clica les lletres correctes. Si Ã©s correcta, es posarÃ  automÃ ticament al seu lloc. Les incorrectes es marcaran amb una <span class="text-red-600 font-black">âœ–</span>.</span></div>
        </div>
        <div class="mt-2 bg-white rounded-xl border p-3">
          <div class="text-xs text-slate-500 mb-2">Lletres disponibles</div>
          <div id="letterBank" class="flex flex-wrap gap-2 justify-center"></div>
        </div>
      </div>
      <div id="level6Area" class="mt-3 hidden">
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
          <div class="bg-white rounded-lg p-2 border">
            <div class="text-xs text-slate-500 mb-1">Infinitive</div>
            <div class="flex items-center gap-2"><select id="selInf" class="w-full border rounded-lg p-2 bg-white"></select><button id="btnSpeakInf" type="button" class="iconBtn" title="ğŸ”Š" disabled>ğŸ”Š</button></div>
          </div>
          <div class="bg-white rounded-lg p-2 border">
            <div class="text-xs text-slate-500 mb-1">Simple past</div>
            <div class="flex items-center gap-2"><select id="selPast" class="w-full border rounded-lg p-2 bg-white"></select><button id="btnSpeakPast" type="button" class="iconBtn" title="ğŸ”Š" disabled>ğŸ”Š</button></div>
          </div>
          <div class="bg-white rounded-lg p-2 border">
            <div class="text-xs text-slate-500 mb-1">Past participle</div>
            <div class="flex items-center gap-2"><select id="selPP" class="w-full border rounded-lg p-2 bg-white"></select><button id="btnSpeakPP" type="button" class="iconBtn" title="ğŸ”Š" disabled>ğŸ”Š</button></div>
          </div>
        </div>
        <button id="btnCheckLevel6" class="mt-2 w-full bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition">
          Comprovar
        </button>
      </div>

      <div class="mt-5">
        <div id="feedback" class="text-base font-bold text-center sm:text-left"></div>
      </div>

      <div class="mt-3 flex items-center justify-between gap-3" id="quizFooter">
        <div class="text-sm text-slate-500">
          <span id="lblQuestion">Pregunta:</span> <span class="font-semibold text-slate-700" id="qIndex">â€”</span> / <span class="font-semibold text-slate-700" id="qTotal">â€”</span>
        </div>
        <button id="btnNext" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition">
          SegÃ¼ent
        </button>
      </div>
    </div>

    
<div class="mb-4" id="progressSection">
      <div class="flex justify-between text-sm text-slate-600 mb-1">
        <span><span id="lblProgress">ProgrÃ©s del nivell</span> <span id="progressRemain" class="text-slate-500"></span></span>
        <span id="progressPct">0%</span>
      </div>
      <div class="w-full bg-slate-200 rounded-full h-3 overflow-hidden">
        <div id="progressBar" class="h-3 bg-blue-500" style="width:0%"></div>
      </div>
      <div class="mt-2 text-sm text-slate-600 flex flex-wrap gap-x-4 gap-y-1 justify-between">
        <div id="scoreLine">Encerts: 0 Â· Errors: 0</div>
        <div id="masterLine">Dominats aquest nivell: 0 / 0</div>
      </div>
    </div>

    
<div id="modal" class="fixed inset-0 bg-black/40 hidden items-center justify-center p-4 z-50">
      <div class="bg-white rounded-2xl p-5 max-w-lg w-full">
        <div id="statsHeader" class="flex justify-between items-center gap-3">
          <h2 id="modalTitle" class="text-xl font-bold"></h2>
          <button id="modalClose" class="text-slate-500 hover:text-slate-800 text-2xl leading-none">&times;</button>
        </div>
        <div id="modalBody" class="mt-3 text-slate-700 text-sm"></div>
        <div class="mt-5 flex justify-end gap-2">
          <button id="modalOk" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition">D'acord</button>
        </div>
      </div>
    </div>
  
<!-- Stats Modal -->
<div id="statsModal" class="fixed inset-0 bg-black/40 hidden items-center justify-center p-4 z-50">
  <div id="statsCard" class="bg-white rounded-2xl p-5 max-w-3xl w-full shadow-xl">
    <div class="flex justify-between items-center gap-3">
      <div class="flex items-center gap-2">
        <span aria-hidden="true">ğŸ“Š</span>
        <h2 id="statsTitle" class="text-xl font-bold">EstadÃ­stiques</h2>
      </div>
      <button id="statsCloseX" class="text-slate-500 hover:text-slate-800 text-2xl leading-none" aria-label="Tancar">&times;</button>
    </div>

    <div class="mt-4 flex gap-2 flex-wrap">
      <button class="statsTabBtn px-3 py-1.5 rounded-full bg-slate-200 text-slate-800 text-sm" data-tab="levels">Per nivell</button>
      <button class="statsTabBtn px-3 py-1.5 rounded-full bg-slate-200 text-slate-800 text-sm" data-tab="difficult">DifÃ­cils</button>
      <button class="statsTabBtn px-3 py-1.5 rounded-full bg-slate-200 text-slate-800 text-sm" data-tab="rounds">Per rondes</button>
    </div>

    <div class="mt-4">
      <div id="statsTab_levels" class="statsTabPanel hidden"></div>
      <div id="statsTab_difficult" class="statsTabPanel hidden"></div>
      <div id="statsTab_rounds" class="statsTabPanel hidden"></div>
    </div>

    <div class="mt-5 flex justify-end gap-2">
      <button id="statsCloseBtn" class="bg-slate-200 text-slate-800 font-bold px-4 py-2 rounded-lg hover:bg-slate-300 transition">Tancar</button>
    </div>
  </div>
</div>
<!-- Verb List Modal -->
<div id="verbListModal" class="fixed inset-0 bg-black/40 hidden items-center justify-center p-3 sm:p-4 z-50">
  <div class="bg-white rounded-2xl shadow-xl w-full max-w-5xl max-h-[90vh] flex flex-col overflow-hidden">
    <div class="px-4 sm:px-5 py-3 border-b flex items-start justify-between gap-3">
      <div class="min-w-0">
        <h2 id="verbListTitle" class="text-lg sm:text-xl font-bold leading-tight">Llista de verbs</h2>
        <p id="verbListSubtitle" class="text-xs sm:text-sm text-slate-600 mt-1">
          <span id="verbListCount" class="font-semibold">0</span>
          <span id="verbListCountSuffix"> verbs</span>
        </p>
      </div>
      <button id="verbListCloseX" class="text-slate-500 hover:text-slate-800 text-2xl leading-none">&times;</button>
    </div>

    <div class="px-4 sm:px-5 py-3 border-b">
      <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
        <div class="text-xs text-slate-600">
          <span id="verbListColorsLabel">Colors:</span>
          <button type="button" class="verbColorBtn inline-block px-2 py-1 rounded bg-emerald-200 ml-2" data-filter="easy">FÃ cil</button>
          <button type="button" class="verbColorBtn inline-block px-2 py-1 rounded bg-yellow-200 ml-1" data-filter="mid">MitjÃ </button>
          <button type="button" class="verbColorBtn inline-block px-2 py-1 rounded bg-orange-200 ml-1" data-filter="hard">DifÃ­cil</button>
        </div>

        <div class="flex gap-2">
          <input id="verbListSearch" class="border rounded-lg px-3 py-2 w-full sm:w-80" placeholder="Cerca..." />
          <button id="verbListCloseBtn" class="bg-slate-200 hover:bg-slate-300 rounded-lg px-3 py-2 font-bold">Tancar</button>
        </div>
      </div>
    </div>

    <div class="flex-1 overflow-auto">
      <div class="overflow-x-auto">
        <table class="min-w-full text-sm">
          <thead class="sticky top-0 bg-slate-50 border-b">
            <tr>
              <th id="verbListThInf" class="text-left px-3 py-2">Infinitiu</th>
              <th id="verbListThPast" class="text-left px-3 py-2">Passat</th>
              <th id="verbListThPP" class="text-left px-3 py-2">Participi</th>
              <th id="verbListThTr" class="text-left px-3 py-2">TraducciÃ³</th>
            </tr>
          </thead>
          <tbody id="verbListTbody"></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

</div>

<script>
const DEFAULT_VERBS = [{"inf": "arise", "past_raw": "arose", "pp_raw": "arisen", "past": "arose", "pp": "arisen", "es": "surgir", "ca": "sorgir", "ka": "áƒ¬áƒáƒ áƒ›áƒáƒ¨áƒáƒ‘áƒ / áƒáƒ¦áƒ›áƒáƒªáƒ”áƒœáƒ”áƒ‘áƒ"}, {"inf": "be", "past_raw": "was / were", "pp_raw": "been", "past": "was", "pp": "been", "es": "ser/estar", "ca": "ser/estar", "ka": "áƒ§áƒáƒ¤áƒœáƒ"}, {"inf": "beat", "past_raw": "beat", "pp_raw": "beaten", "past": "beat", "pp": "beaten", "es": "golpear / vencer", "ca": "colpejar / vÃ¨ncer", "ka": "áƒªáƒ”áƒ›áƒ / áƒ“áƒáƒ áƒ¢áƒ§áƒ›áƒ"}, {"inf": "become", "past_raw": "became", "pp_raw": "become", "past": "became", "pp": "become", "es": "convertirse en", "ca": "esdevenir / convertir-se en", "ka": "áƒ’áƒáƒ®áƒ“áƒáƒ›áƒ"}, {"inf": "begin", "past_raw": "began", "pp_raw": "begun", "past": "began", "pp": "begun", "es": "empezar", "ca": "comenÃ§ar", "ka": "áƒ“áƒáƒ¬áƒ§áƒ”áƒ‘áƒ"}, {"inf": "bet", "past_raw": "bet/betted", "pp_raw": "bet/betted", "past": "bet", "pp": "bet", "es": "apostar", "ca": "apostar", "ka": "áƒ“áƒáƒœáƒáƒ«áƒšáƒ”áƒ•áƒ”áƒ‘áƒ"}, {"inf": "bite", "past_raw": "bit", "pp_raw": "bitten", "past": "bit", "pp": "bitten", "es": "morder", "ca": "mossegar", "ka": "áƒ™áƒ‘áƒ”áƒœáƒ"}, {"inf": "bleed", "past_raw": "bled", "pp_raw": "bled", "past": "bled", "pp": "bled", "es": "sangrar", "ca": "sagnar", "ka": "áƒ¡áƒ˜áƒ¡áƒ®áƒšáƒ“áƒ”áƒœáƒ"}, {"inf": "blow", "past_raw": "blew", "pp_raw": "blown", "past": "blew", "pp": "blown", "es": "soplar", "ca": "bufar", "ka": "áƒ“áƒáƒ‘áƒ”áƒ áƒ•áƒ"}, {"inf": "break", "past_raw": "broke", "pp_raw": "broken", "past": "broke", "pp": "broken", "es": "romper", "ca": "trencar", "ka": "áƒ’áƒáƒ¢áƒ”áƒ®áƒ•áƒ"}, {"inf": "bring", "past_raw": "brought", "pp_raw": "brought", "past": "brought", "pp": "brought", "es": "traer", "ca": "portar", "ka": "áƒ›áƒáƒ¢áƒáƒœáƒ"}, {"inf": "build", "past_raw": "built", "pp_raw": "built", "past": "built", "pp": "built", "es": "construir", "ca": "construir", "ka": "áƒáƒ¨áƒ”áƒœáƒ”áƒ‘áƒ"}, {"inf": "buy", "past_raw": "bought", "pp_raw": "bought", "past": "bought", "pp": "bought", "es": "comprar", "ca": "comprar", "ka": "áƒ§áƒ˜áƒ“áƒ•áƒ"}, {"inf": "catch", "past_raw": "caught", "pp_raw": "caught", "past": "caught", "pp": "caught", "es": "atrapar", "ca": "atrapar / agafar", "ka": "áƒ“áƒáƒ­áƒ”áƒ áƒ"}, {"inf": "choose", "past_raw": "chose", "pp_raw": "chosen", "past": "chose", "pp": "chosen", "es": "elegir", "ca": "triar / escollir", "ka": "áƒáƒ áƒ©áƒ”áƒ•áƒ"}, {"inf": "come", "past_raw": "came", "pp_raw": "come", "past": "came", "pp": "come", "es": "venir", "ca": "venir", "ka": "áƒ›áƒáƒ¡áƒ•áƒšáƒ"}, {"inf": "cost", "past_raw": "cost", "pp_raw": "cost", "past": "cost", "pp": "cost", "es": "costar", "ca": "costar", "ka": "áƒ¦áƒ˜áƒ áƒ”áƒ‘áƒ"}, {"inf": "creep", "past_raw": "crept", "pp_raw": "crept", "past": "crept", "pp": "crept", "es": "arrastrarse", "ca": "arrossegar-se", "ka": "áƒªáƒáƒªáƒ•áƒ"}, {"inf": "cut", "past_raw": "cut", "pp_raw": "cut", "past": "cut", "pp": "cut", "es": "cortar", "ca": "tallar", "ka": "áƒ­áƒ áƒ"}, {"inf": "deal", "past_raw": "dealt", "pp_raw": "dealt", "past": "dealt", "pp": "dealt", "es": "tratar (con) / repartir", "ca": "tractar (amb) / repartir", "ka": "áƒ’áƒáƒ áƒ˜áƒ’áƒ”áƒ‘áƒ / áƒ•áƒáƒ­áƒ áƒáƒ‘áƒ"}, {"inf": "do", "past_raw": "did", "pp_raw": "done", "past": "did", "pp": "done", "es": "hacer", "ca": "fer", "ka": "áƒ™áƒ”áƒ—áƒ”áƒ‘áƒ"}, {"inf": "draw", "past_raw": "drew", "pp_raw": "drawn", "past": "drew", "pp": "drawn", "es": "dibujar", "ca": "dibuixar", "ka": "áƒ®áƒáƒ¢áƒ•áƒ / áƒ®áƒáƒ–áƒ•áƒ"}, {"inf": "dream", "past_raw": "dreamt/dreamed", "pp_raw": "dreamt/dreamed", "past": "dreamt", "pp": "dreamt", "es": "soÃ±ar", "ca": "somiar", "ka": "áƒáƒªáƒœáƒ”áƒ‘áƒ"}, {"inf": "drink", "past_raw": "drank", "pp_raw": "drunk", "past": "drank", "pp": "drunk", "es": "beber", "ca": "beure", "ka": "áƒ“áƒáƒšáƒ”áƒ•áƒ"}, {"inf": "drive", "past_raw": "drove", "pp_raw": "driven", "past": "drove", "pp": "driven", "es": "conducir", "ca": "conduir", "ka": "áƒ›áƒáƒ áƒ—áƒ•áƒ"}, {"inf": "eat", "past_raw": "ate", "pp_raw": "eaten", "past": "ate", "pp": "eaten", "es": "comer", "ca": "menjar", "ka": "áƒ­áƒáƒ›áƒ"}, {"inf": "fall", "past_raw": "fell", "pp_raw": "fallen", "past": "fell", "pp": "fallen", "es": "caer", "ca": "caure", "ka": "áƒ“áƒáƒªáƒ”áƒ›áƒ"}, {"inf": "feed", "past_raw": "fed", "pp_raw": "fed", "past": "fed", "pp": "fed", "es": "alimentar", "ca": "alimentar", "ka": "áƒ™áƒ•áƒ”áƒ‘áƒ"}, {"inf": "feel", "past_raw": "felt", "pp_raw": "felt", "past": "felt", "pp": "felt", "es": "sentir", "ca": "sentir", "ka": "áƒ’áƒ áƒ«áƒœáƒáƒ‘áƒ"}, {"inf": "fight", "past_raw": "fought", "pp_raw": "fought", "past": "fought", "pp": "fought", "es": "luchar", "ca": "lluitar", "ka": "áƒ‘áƒ áƒ«áƒáƒšáƒ"}, {"inf": "find", "past_raw": "found", "pp_raw": "found", "past": "found", "pp": "found", "es": "encontrar", "ca": "trobar", "ka": "áƒáƒáƒ•áƒœáƒ"}, {"inf": "flee", "past_raw": "fled", "pp_raw": "fled", "past": "fled", "pp": "fled", "es": "huir", "ca": "fugir", "ka": "áƒ’áƒáƒ¥áƒªáƒ”áƒ•áƒ"}, {"inf": "fly", "past_raw": "flew", "pp_raw": "flown", "past": "flew", "pp": "flown", "es": "volar", "ca": "volar", "ka": "áƒ¤áƒ áƒ”áƒœáƒ"}, {"inf": "forget", "past_raw": "forgot", "pp_raw": "forgotten", "past": "forgot", "pp": "forgotten", "es": "olvidar", "ca": "oblidar", "ka": "áƒ“áƒáƒ•áƒ˜áƒ¬áƒ§áƒ”áƒ‘áƒ"}, {"inf": "forgive", "past_raw": "forgave", "pp_raw": "forgiven", "past": "forgave", "pp": "forgiven", "es": "perdonar", "ca": "perdonar", "ka": "áƒ›áƒ˜áƒ¢áƒ”áƒ•áƒ”áƒ‘áƒ"}, {"inf": "forsake", "past_raw": "forsook", "pp_raw": "forsaken", "past": "forsook", "pp": "forsaken", "es": "abandonar", "ca": "abandonar", "ka": "áƒ›áƒ˜áƒ¢áƒáƒ•áƒ”áƒ‘áƒ"}, {"inf": "freeze", "past_raw": "froze", "pp_raw": "frozen", "past": "froze", "pp": "frozen", "es": "congelar(se)", "ca": "congelar(-se)", "ka": "áƒ’áƒáƒ§áƒ˜áƒœáƒ•áƒ"}, {"inf": "get", "past_raw": "got", "pp_raw": "got", "past": "got", "pp": "got", "es": "conseguir / obtener", "ca": "aconseguir / obtenir", "ka": "áƒ›áƒ˜áƒ¦áƒ”áƒ‘áƒ"}, {"inf": "give", "past_raw": "gave", "pp_raw": "given", "past": "gave", "pp": "given", "es": "dar", "ca": "donar", "ka": "áƒ›áƒ˜áƒªáƒ”áƒ›áƒ"}, {"inf": "go", "past_raw": "went", "pp_raw": "gone", "past": "went", "pp": "gone", "es": "ir", "ca": "anar", "ka": "áƒ¬áƒáƒ¡áƒ•áƒšáƒ"}, {"inf": "grind", "past_raw": "ground", "pp_raw": "ground", "past": "ground", "pp": "ground", "es": "moler / triturar", "ca": "moldre / triturar", "ka": "áƒ“áƒáƒ¤áƒ¥áƒ•áƒ"}, {"inf": "grow", "past_raw": "grew", "pp_raw": "grown", "past": "grew", "pp": "grown", "es": "crecer", "ca": "crÃ©ixer", "ka": "áƒ’áƒáƒ–áƒ áƒ“áƒ"}, {"inf": "hang", "past_raw": "hung", "pp_raw": "hung", "past": "hung", "pp": "hung", "es": "colgar", "ca": "penjar", "ka": "áƒ“áƒáƒ™áƒ˜áƒ“áƒ”áƒ‘áƒ"}, {"inf": "have", "past_raw": "had", "pp_raw": "had", "past": "had", "pp": "had", "es": "tener", "ca": "tenir", "ka": "áƒ¥áƒáƒœáƒ"}, {"inf": "hear", "past_raw": "heard", "pp_raw": "heard", "past": "heard", "pp": "heard", "es": "oÃ­r", "ca": "sentir (oÃ¯da)", "ka": "áƒ¡áƒ›áƒ”áƒœáƒ"}, {"inf": "hide", "past_raw": "hid", "pp_raw": "hidden", "past": "hid", "pp": "hidden", "es": "esconder", "ca": "amagar", "ka": "áƒ“áƒáƒ›áƒáƒšáƒ•áƒ"}, {"inf": "hit", "past_raw": "hit", "pp_raw": "hit", "past": "hit", "pp": "hit", "es": "golpear", "ca": "colpejar", "ka": "áƒ“áƒáƒ áƒ¢áƒ§áƒ›áƒ"}, {"inf": "hold", "past_raw": "held", "pp_raw": "held", "past": "held", "pp": "held", "es": "sostener / aguantar", "ca": "aguantar / sostenir", "ka": "áƒ“áƒáƒ­áƒ”áƒ áƒ / áƒ“áƒáƒ­áƒ”áƒ áƒ-áƒ¨áƒ”áƒœáƒáƒ áƒ©áƒ£áƒœáƒ”áƒ‘áƒ"}, {"inf": "hurt", "past_raw": "hurt", "pp_raw": "hurt", "past": "hurt", "pp": "hurt", "es": "herir / doler", "ca": "ferir / fer mal", "ka": "áƒ¢áƒ™áƒ”áƒœáƒ / áƒ“áƒáƒ–áƒ˜áƒáƒœáƒ”áƒ‘áƒ"}, {"inf": "keep", "past_raw": "kept", "pp_raw": "kept", "past": "kept", "pp": "kept", "es": "mantener / guardar", "ca": "mantenir / guardar", "ka": "áƒ¨áƒ”áƒœáƒáƒ áƒ©áƒ£áƒœáƒ”áƒ‘áƒ / áƒ¨áƒ”áƒœáƒáƒ®áƒ•áƒ"}, {"inf": "kneel", "past_raw": "knelt", "pp_raw": "knelt", "past": "knelt", "pp": "knelt", "es": "arrodillarse", "ca": "agenollar-se", "ka": "áƒ“áƒáƒ©áƒáƒ¥áƒ”áƒ‘áƒ"}, {"inf": "know", "past_raw": "knew", "pp_raw": "known", "past": "knew", "pp": "known", "es": "saber / conocer", "ca": "saber / conÃ¨ixer", "ka": "áƒªáƒáƒ“áƒœáƒ / áƒ’áƒáƒªáƒœáƒáƒ‘áƒ"}, {"inf": "lead", "past_raw": "led", "pp_raw": "led", "past": "led", "pp": "led", "es": "liderar / guiar", "ca": "liderar / guiar", "ka": "áƒ¬áƒáƒ§áƒ•áƒáƒœáƒ / áƒ®áƒ”áƒšáƒ›áƒ«áƒ¦áƒ•áƒáƒœáƒ”áƒšáƒáƒ‘áƒ"}, {"inf": "learn", "past_raw": "learnt/learned", "pp_raw": "learnt/learned", "past": "learnt", "pp": "learnt", "es": "aprender", "ca": "aprendre", "ka": "áƒ¡áƒ¬áƒáƒ•áƒšáƒ"}, {"inf": "leave", "past_raw": "left", "pp_raw": "left", "past": "left", "pp": "left", "es": "dejar / irse", "ca": "deixar / marxar", "ka": "áƒ“áƒáƒ¢áƒáƒ•áƒ”áƒ‘áƒ"}, {"inf": "lend", "past_raw": "lent", "pp_raw": "lent", "past": "lent", "pp": "lent", "es": "prestar", "ca": "prestar", "ka": "áƒ¡áƒ”áƒ¡áƒ®áƒ”áƒ‘áƒ"}, {"inf": "let", "past_raw": "let", "pp_raw": "let", "past": "let", "pp": "let", "es": "dejar / permitir", "ca": "deixar / permetre", "ka": "áƒ“áƒáƒ¨áƒ•áƒ”áƒ‘áƒ / áƒœáƒ”áƒ‘áƒ áƒ“áƒáƒ áƒ—áƒ•áƒ"}, {"inf": "lie", "past_raw": "lay", "pp_raw": "lain", "past": "lay", "pp": "lain", "es": "tumbarse / yacer", "ca": "jeure / estirar-se", "ka": "áƒ¬áƒáƒšáƒ"}, {"inf": "lose", "past_raw": "lost", "pp_raw": "lost", "past": "lost", "pp": "lost", "es": "perder", "ca": "perdre", "ka": "áƒ“áƒáƒ™áƒáƒ áƒ’áƒ•áƒ"}, {"inf": "make", "past_raw": "made", "pp_raw": "made", "past": "made", "pp": "made", "es": "hacer / fabricar", "ca": "fer / fabricar", "ka": "áƒ’áƒáƒ™áƒ”áƒ—áƒ”áƒ‘áƒ / áƒ¨áƒ”áƒ¥áƒ›áƒœáƒ"}, {"inf": "mean", "past_raw": "meant", "pp_raw": "meant", "past": "meant", "pp": "meant", "es": "significar", "ca": "significar / voler dir", "ka": "áƒœáƒ˜áƒ¨áƒœáƒáƒ•áƒ“áƒ”áƒ¡"}, {"inf": "meet", "past_raw": "met", "pp_raw": "met", "past": "met", "pp": "met", "es": "conocer / encontrarse", "ca": "conÃ¨ixer / trobar-se", "ka": "áƒ¨áƒ”áƒ®áƒ•áƒ”áƒ“áƒ áƒ / áƒ’áƒáƒªáƒœáƒáƒ‘áƒ"}, {"inf": "pay", "past_raw": "paid", "pp_raw": "paid", "past": "paid", "pp": "paid", "es": "pagar", "ca": "pagar", "ka": "áƒ’áƒáƒ“áƒáƒ®áƒ“áƒ"}, {"inf": "put", "past_raw": "put", "pp_raw": "put", "past": "put", "pp": "put", "es": "poner", "ca": "posar", "ka": "áƒ“áƒáƒ“áƒ”áƒ‘áƒ / áƒ©áƒáƒ“áƒ”áƒ‘áƒ"}, {"inf": "quit", "past_raw": "quit/quitted", "pp_raw": "quit/quitted", "past": "quit", "pp": "quit", "es": "dejar / abandonar", "ca": "deixar / abandonar", "ka": "áƒ¨áƒ”áƒ¬áƒ§áƒ•áƒ”áƒ¢áƒ / áƒ›áƒ˜áƒ¢áƒáƒ•áƒ”áƒ‘áƒ"}, {"inf": "read", "past_raw": "read", "pp_raw": "read", "past": "read", "pp": "read", "es": "leer", "ca": "llegir", "ka": "áƒ™áƒ˜áƒ—áƒ®áƒ•áƒ"}, {"inf": "ride", "past_raw": "rode", "pp_raw": "ridden", "past": "rode", "pp": "ridden", "es": "montar (en bici/caballo)", "ca": "muntar (en bici/cavall)", "ka": "áƒ¢áƒáƒ áƒ”áƒ‘áƒ / áƒªáƒ®áƒ”áƒœáƒáƒ¡áƒœáƒáƒ‘áƒ"}, {"inf": "ring", "past_raw": "rang", "pp_raw": "rung", "past": "rang", "pp": "rung", "es": "sonar / llamar", "ca": "sonar / trucar", "ka": "áƒ“áƒáƒ áƒ”áƒ™áƒ•áƒ"}, {"inf": "rise", "past_raw": "rose", "pp_raw": "risen", "past": "rose", "pp": "risen", "es": "levantarse / subir", "ca": "aixecar-se / pujar", "ka": "áƒáƒ›áƒáƒ¦áƒšáƒ”áƒ‘áƒ / áƒáƒ¬áƒ”áƒ•áƒ"}, {"inf": "run", "past_raw": "ran", "pp_raw": "run", "past": "ran", "pp": "run", "es": "correr", "ca": "cÃ³rrer", "ka": "áƒ¡áƒ˜áƒ áƒ‘áƒ˜áƒšáƒ˜"}, {"inf": "say", "past_raw": "said", "pp_raw": "said", "past": "said", "pp": "said", "es": "decir", "ca": "dir", "ka": "áƒ—áƒ¥áƒ›áƒ"}, {"inf": "see", "past_raw": "saw", "pp_raw": "seen", "past": "saw", "pp": "seen", "es": "ver", "ca": "veure", "ka": "áƒœáƒáƒ®áƒ•áƒ"}, {"inf": "sell", "past_raw": "sold", "pp_raw": "sold", "past": "sold", "pp": "sold", "es": "vender", "ca": "vendre", "ka": "áƒ’áƒáƒ§áƒ˜áƒ“áƒ•áƒ"}, {"inf": "send", "past_raw": "sent", "pp_raw": "sent", "past": "sent", "pp": "sent", "es": "enviar", "ca": "enviar", "ka": "áƒ’áƒáƒ’áƒ–áƒáƒ•áƒœáƒ"}, {"inf": "set", "past_raw": "set", "pp_raw": "set", "past": "set", "pp": "set", "es": "poner / establecer", "ca": "posar / establir", "ka": "áƒ“áƒáƒ§áƒ”áƒœáƒ”áƒ‘áƒ / áƒ“áƒáƒ§áƒ”áƒœáƒ”áƒ‘áƒ-áƒ©áƒáƒ§áƒ”áƒœáƒ”áƒ‘áƒ"}, {"inf": "sew", "past_raw": "sewed", "pp_raw": "sewn/sewed", "past": "sewed", "pp": "sewn", "es": "coser", "ca": "cosir", "ka": "áƒ™áƒ”áƒ áƒ•áƒ"}, {"inf": "shake", "past_raw": "shook", "pp_raw": "shaken", "past": "shook", "pp": "shaken", "es": "sacudir", "ca": "sacsejar", "ka": "áƒ¨áƒ”áƒ áƒ§áƒ”áƒ•áƒ"}, {"inf": "shine", "past_raw": "shone", "pp_raw": "shone", "past": "shone", "pp": "shone", "es": "brillar", "ca": "brillar", "ka": "áƒ‘áƒ áƒ¬áƒ§áƒ˜áƒœáƒ•áƒ"}, {"inf": "shoot", "past_raw": "shot", "pp_raw": "shot", "past": "shot", "pp": "shot", "es": "disparar", "ca": "disparar", "ka": "áƒ¡áƒ áƒáƒšáƒ"}, {"inf": "show", "past_raw": "showed", "pp_raw": "shown/showed", "past": "showed", "pp": "shown", "es": "mostrar", "ca": "mostrar", "ka": "áƒ©áƒ•áƒ”áƒœáƒ”áƒ‘áƒ"}, {"inf": "shrink", "past_raw": "shrank/shrunk", "pp_raw": "shrunk", "past": "shrank", "pp": "shrunk", "es": "encoger", "ca": "encongir-se", "ka": "áƒ¨áƒ”áƒ™áƒ£áƒ›áƒ¨áƒ•áƒ / áƒ“áƒáƒáƒáƒ¢áƒáƒ áƒáƒ•áƒ”áƒ‘áƒ"}, {"inf": "shut", "past_raw": "shut", "pp_raw": "shut", "past": "shut", "pp": "shut", "es": "cerrar", "ca": "tancar", "ka": "áƒ“áƒáƒ®áƒ£áƒ áƒ•áƒ"}, {"inf": "sing", "past_raw": "sang", "pp_raw": "sung", "past": "sang", "pp": "sung", "es": "cantar", "ca": "cantar", "ka": "áƒ¡áƒ˜áƒ›áƒ¦áƒ”áƒ áƒ"}, {"inf": "sink", "past_raw": "sank", "pp_raw": "sunk", "past": "sank", "pp": "sunk", "es": "hundirse", "ca": "enfonsar-se", "ka": "áƒ©áƒáƒ«áƒ˜áƒ áƒ•áƒ"}, {"inf": "sit", "past_raw": "sat", "pp_raw": "sat", "past": "sat", "pp": "sat", "es": "sentarse", "ca": "seure", "ka": "áƒ¯áƒ“áƒáƒ›áƒ"}, {"inf": "sleep", "past_raw": "slept", "pp_raw": "slept", "past": "slept", "pp": "slept", "es": "dormir", "ca": "dormir", "ka": "áƒ«áƒ˜áƒšáƒ˜"}, {"inf": "slide", "past_raw": "slid", "pp_raw": "slid", "past": "slid", "pp": "slid", "es": "deslizar(se)", "ca": "lliscar", "ka": "áƒ¡áƒ áƒ˜áƒáƒšáƒ˜"}, {"inf": "sow", "past_raw": "sowed", "pp_raw": "sown/sowed", "past": "sowed", "pp": "sown", "es": "sembrar", "ca": "sembrar", "ka": "áƒ—áƒ”áƒ¡áƒ•áƒ"}, {"inf": "speak", "past_raw": "spoke", "pp_raw": "spoken", "past": "spoke", "pp": "spoken", "es": "hablar", "ca": "parlar", "ka": "áƒšáƒáƒáƒáƒ áƒáƒ™áƒ˜"}, {"inf": "spell", "past_raw": "spelt/spelled", "pp_raw": "spelt/spelled", "past": "spelt", "pp": "spelt", "es": "deletrear", "ca": "lletrejar", "ka": "áƒ›áƒáƒ áƒªáƒ•áƒšáƒ”áƒ‘áƒ˜áƒ— áƒ“áƒáƒ¬áƒ”áƒ áƒ"}, {"inf": "spend", "past_raw": "spent", "pp_raw": "spent", "past": "spent", "pp": "spent", "es": "gastar / pasar (tiempo)", "ca": "gastar / passar (temps)", "ka": "áƒ“áƒáƒ®áƒáƒ áƒ¯áƒ•áƒ"}, {"inf": "spill", "past_raw": "spilt/spilled", "pp_raw": "spilt/spilled", "past": "spilt", "pp": "spilt", "es": "derramar", "ca": "vessar", "ka": "áƒ“áƒáƒ¦áƒ•áƒ áƒ"}, {"inf": "split", "past_raw": "split", "pp_raw": "split", "past": "split", "pp": "split", "es": "dividir / partir", "ca": "dividir / partir", "ka": "áƒ’áƒáƒ§áƒáƒ¤áƒ"}, {"inf": "spoil", "past_raw": "spoilt/spoiled", "pp_raw": "spoilt/spoiled", "past": "spoilt", "pp": "spoilt", "es": "estropear", "ca": "espatllar", "ka": "áƒ’áƒáƒ¤áƒ£áƒ­áƒ”áƒ‘áƒ"}, {"inf": "spread", "past_raw": "spread", "pp_raw": "spread", "past": "spread", "pp": "spread", "es": "extender / difundir", "ca": "estendre / escampar", "ka": "áƒ’áƒáƒ•áƒ áƒªáƒ”áƒšáƒ”áƒ‘áƒ"}, {"inf": "stand", "past_raw": "stood", "pp_raw": "stood", "past": "stood", "pp": "stood", "es": "estar de pie", "ca": "estar dret", "ka": "áƒ“áƒ’áƒáƒ›áƒ"}, {"inf": "steal", "past_raw": "stole", "pp_raw": "stolen", "past": "stole", "pp": "stolen", "es": "robar", "ca": "robar", "ka": "áƒ¥áƒ£áƒ áƒ“áƒáƒ‘áƒ"}, {"inf": "sting", "past_raw": "stung", "pp_raw": "stung", "past": "stung", "pp": "stung", "es": "picar", "ca": "picar", "ka": "áƒ“áƒáƒ™áƒ‘áƒ”áƒœáƒ / áƒœáƒ”áƒ¡áƒ¢áƒ áƒ˜áƒ— áƒ©áƒ®áƒ•áƒšáƒ”áƒ¢áƒ"}, {"inf": "stink", "past_raw": "stank/stunk", "pp_raw": "stunk", "past": "stank", "pp": "stunk", "es": "apestar / oler mal", "ca": "fer pudor", "ka": "áƒ§áƒ áƒáƒšáƒ"}, {"inf": "strike", "past_raw": "struck", "pp_raw": "struck", "past": "struck", "pp": "struck", "es": "golpear", "ca": "colpejar", "ka": "áƒ“áƒáƒ áƒ¢áƒ§áƒ›áƒ"}, {"inf": "swear", "past_raw": "swore", "pp_raw": "sworn", "past": "swore", "pp": "sworn", "es": "jurar", "ca": "jurar", "ka": "áƒ¤áƒ˜áƒªáƒ”áƒ‘áƒ"}, {"inf": "sweep", "past_raw": "swept", "pp_raw": "swept", "past": "swept", "pp": "swept", "es": "barrer", "ca": "escombrar", "ka": "áƒ›áƒáƒ®áƒ•áƒ”áƒ¢áƒ"}, {"inf": "swim", "past_raw": "swam", "pp_raw": "swum", "past": "swam", "pp": "swum", "es": "nadar", "ca": "nedar", "ka": "áƒªáƒ£áƒ áƒ•áƒ"}, {"inf": "take", "past_raw": "took", "pp_raw": "taken", "past": "took", "pp": "taken", "es": "tomar / coger", "ca": "agafar / prendre", "ka": "áƒáƒ¦áƒ”áƒ‘áƒ"}, {"inf": "teach", "past_raw": "taught", "pp_raw": "taught", "past": "taught", "pp": "taught", "es": "enseÃ±ar", "ca": "ensenyar", "ka": "áƒ¡áƒ¬áƒáƒ•áƒšáƒ”áƒ‘áƒ"}, {"inf": "tear", "past_raw": "tore", "pp_raw": "torn", "past": "tore", "pp": "torn", "es": "rasgar", "ca": "esquinÃ§ar", "ka": "áƒ“áƒáƒ®áƒ”áƒ•áƒ"}, {"inf": "tell", "past_raw": "told", "pp_raw": "told", "past": "told", "pp": "told", "es": "decir / contar", "ca": "dir / explicar", "ka": "áƒ›áƒáƒ§áƒáƒšáƒ / áƒ—áƒ¥áƒ›áƒ"}, {"inf": "think", "past_raw": "thought", "pp_raw": "thought", "past": "thought", "pp": "thought", "es": "pensar", "ca": "pensar", "ka": "áƒ¤áƒ˜áƒ¥áƒ áƒ˜"}, {"inf": "throw", "past_raw": "threw", "pp_raw": "thrown", "past": "threw", "pp": "thrown", "es": "tirar / lanzar", "ca": "llenÃ§ar", "ka": "áƒ’áƒáƒ“áƒáƒ’áƒ“áƒ”áƒ‘áƒ"}, {"inf": "tread", "past_raw": "trode", "pp_raw": "trodden/trod", "past": "trode", "pp": "trodden", "es": "pisar", "ca": "trepitjar", "ka": "áƒ¤áƒ”áƒ®áƒ˜áƒ¡ áƒ“áƒáƒ“áƒ’áƒ›áƒ / áƒ’áƒáƒ—áƒ”áƒšáƒ•áƒ"}, {"inf": "understand", "past_raw": "understood", "pp_raw": "understood", "past": "understood", "pp": "understood", "es": "entender", "ca": "entendre", "ka": "áƒ’áƒáƒ’áƒ”áƒ‘áƒ"}, {"inf": "wake", "past_raw": "woke", "pp_raw": "woken", "past": "woke", "pp": "woken", "es": "despertar(se)", "ca": "despertar(-se)", "ka": "áƒ’áƒáƒ¦áƒ•áƒ˜áƒ«áƒ”áƒ‘áƒ"}, {"inf": "wear", "past_raw": "wore", "pp_raw": "worn", "past": "wore", "pp": "worn", "es": "llevar puesto / vestir", "ca": "portar (roba) / vestir", "ka": "áƒ¢áƒáƒ áƒ”áƒ‘áƒ / áƒ©áƒáƒªáƒ›áƒ"}, {"inf": "weave", "past_raw": "wove", "pp_raw": "woven", "past": "wove", "pp": "woven", "es": "tejer", "ca": "teixir", "ka": "áƒ¥áƒ¡áƒáƒ•áƒ"}, {"inf": "weep", "past_raw": "wept", "pp_raw": "wept", "past": "wept", "pp": "wept", "es": "llorar", "ca": "plorar", "ka": "áƒ¢áƒ˜áƒ áƒ˜áƒšáƒ˜"}, {"inf": "win", "past_raw": "won", "pp_raw": "won", "past": "won", "pp": "won", "es": "ganar", "ca": "guanyar", "ka": "áƒ›áƒáƒ’áƒ”áƒ‘áƒ"}, {"inf": "wring", "past_raw": "wrung", "pp_raw": "wrung", "past": "wrung", "pp": "wrung", "es": "retorcer / escurrir", "ca": "torÃ§ar / escÃ³rrer", "ka": "áƒ’áƒáƒ›áƒáƒ¬áƒ£áƒ áƒ•áƒ"}, {"inf": "write", "past_raw": "wrote", "pp_raw": "written", "past": "wrote", "pp": "written", "es": "escribir", "ca": "escriure", "ka": "áƒ¬áƒ”áƒ áƒ"}];

/* Correccions de traducciÃ³ al catalÃ  (evita ambigÃ¼itats sense revelar la resposta) */
const CA_OVERRIDES = {
  "hit": "tocar / colpejar",
  "strike": "colpejar",
  "beat": "batre / vÃ¨ncer"
};
function displayCa(v){
  const inf = v && v.inf ? v.inf : "";
  return (CA_OVERRIDES[inf] || (v && v.ca) || (v && v.inf) || "").trim();
}
const DEV_UNLOCK = new URLSearchParams(location.search).get("dev") === "1";
if(DEV_UNLOCK) document.getElementById("devHint").classList.remove("hidden");

const LANG_KEY = "irregular_verbs_lang_v1";
const UI = {
  ca: {
    title: "Verbs Irregulars anglesos",
  subtitle: "6 nivells. No pugis de nivell fins haver encertat tots els verbs almenys 1 cop.",
    howItWorks: "Instruccions",
    favOnly: "NomÃ©s â­",
    resetStars: "Reinicia â­",
    reset: "Reinicia",
    resetModalTitle: "Reinicia progrÃ©s",
    resetConfirmBody: (lvl)=>`Vols reiniciar el progrÃ©s del <b>${UI[getLang()].level(lvl)}</b>?`,
    resetWarn: "AixÃ² no es pot desfer. Els altres nivells es conservaran.",
    resetConfirmBtn: "SÃ­, reinicia",
    cancel: "CancelÂ·la",
    levelCompleteTitle: "Nivell completat!",
    levelCompleteBody: (lvl)=>`Has completat el <b>${UI[getLang()].level(lvl)}</b>. Vols reiniciar aquest nivell o passar al segÃ¼ent?`,

    nextLevelBtn: "SegÃ¼ent nivell",
    resetThisLevelBtn: "Reinicia aquest nivell",
    list: "Llista de verbs",
    tenseInf: "Infinitiu",
    tensePast: "Passat simple",
    tensePP: "Participi passat",
    progress: "ProgrÃ©s del nivell",
    correctWrong: (c,w)=>`Encerts: ${c} Â· Errors: ${w}`,
    masteredLine: (m,t)=>`Dominats aquest nivell: ${m} / ${t}`,
    question: "Pregunta:",
    next: "SegÃ¼ent",
    selectLevelToStart: "Selecciona un nivell per comenÃ§ar",
    lockedLevel: "ğŸ”’ Aquest nivell estÃ  bloquejat. Completa el nivell anterior primer.",
    helpTitle: "Instruccions",
    helpBody: `<ul class="list-disc pl-5 space-y-1">
      <li><b>N1</b>: tria el significat en catalÃ .</li>
      <li><b>N2</b>: tria l'infinitiu en anglÃ¨s a partir del catalÃ .</li>
      <li><b>N3</b>: completa el verb en anglÃ¨s amb lletres.</li>
      <li><b>N4</b>: tria el <b>Simple Past</b> correcte.</li>
      <li><b>N5</b>: tria el <b>Past Participle</b> correcte.</li>
      <li><b>N6</b>: omple infinitive + simple past + past participle (pots provar tantes vegades com calgui).</li>
    </ul>`,
    ok: "D'acord",
    lvlCompleted: (lvl)=>UI[getLang()].lvlCompleted(lvl),
    lvlCompletedBody: (lvl)=>`<p>Has encertat <b>tots</b> els verbs almenys una vegada.</p><p class="mt-2">Ja pots desbloquejar el <b>Nivell ${lvl+1}</b>.</p>
      <div class="mt-4 flex flex-wrap gap-2 justify-end">
        <button id="btnResetAfterComplete" class="bg-red-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-red-700 transition">${UI[getLang()].resetThisLevelBtn}</button>
        <button id="btnNextLevel" class="bg-blue-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-blue-700 transition">${UI[getLang()].nextLevelBtn}</button>
      </div>
    `,
    gameDoneTitle: "ğŸ‰ Joc completat!",
    gameDoneBody: "<p>Has completat tots els nivells amb tots els verbs!</p>",
    level: (lvl)=>`Nivell ${lvl}`,
    hintL1: "Tria el significat en catalÃ :",
    hintL2: "Tria el verb en anglÃ¨s (infinitiu):",
    hintL3: "Completa el verb en anglÃ¨s amb les lletres:",
    hintL4: "Tria el SIMPLE PAST correcte:",
    hintL5: "Tria el PAST PARTICIPLE correcte:",
    hintL6: "Omple <b>infinitive + simple past + past participle</b>. Pots comprovar tantes vegades com calgui fins encertar les 3.",
    good: "ğŸ˜Š Molt bÃ©!",
    notCorrect: "ğŸ˜¢ No Ã©s correcte.",
    needAllSelects: "ğŸ˜• Selecciona una opciÃ³ a cada desplegable.",
    stillNot: "ğŸ˜¢ Encara no. Revisa els selectors en vermell i torna a provar.",
    lvl6Good: "ğŸ˜Š Molt bÃ©! (Nivell 6 completat per aquest verb)",
    pronounceTitle: "Escoltar pronunciaciÃ³",
    letterExplain: '<span id="lblLetterExplain">Clica les lletres correctes. Si Ã©s correcta, es posarÃ  automÃ ticament al seu lloc. Les incorrectes es marcaran amb una <span class="text-red-600 font-black">âœ–</span>.</span>',
    listTitle: "Llista de verbs irregulars",
    listSubtitle: "Infinitive, Simple Past, Past Participle i significat.",
    starCol: "â­",
    meaningCol: "Significat",
    searchPh: "Cerca (infinitiu / formes / significat)...",
    close: "Tancar",
    statsTitle: "EstadÃ­stiques",
    statsTabs: { levels: "Per nivell", difficult: "DifÃ­cils", rounds: "Per rondes" },
    statsLevelsHead: { level:"Nivell", mastered:"Dominats", pct:"% Dominats", correct:"Encerts", wrong:"Errors", rounds:"Rondes" },
    statsDiffEmpty: "Encara no hi ha errors registrats.",
    statsDiffErrors: "errors",
    statsRoundsHead: { level:"Nivell", round:"Ronda actual", accRound:"PrecisiÃ³ (ronda)", accTotal:"PrecisiÃ³ total", delta:"Î” millora" },
    statsRoundsNote: "â€œRonda actualâ€ Ã©s el nÃºmero de ronda del nivell. Reiniciar inicia una nova ronda perÃ² guarda lâ€™histÃ²ric per veure lâ€™evoluciÃ³.",
    colors: {
      label: "Colors:",
      easy: "FÃ cils (3 iguals)",
      mid: "Mitjans (2 iguals)",
      hard: "DifÃ­cils (3 diferents)"
    },
    meaningHeader: "CatalÃ "
  },
  es: {
    title: "Verbos Irregulares ingleses",
  subtitle: "6 niveles. No subas de nivel hasta haber acertado todos los verbos al menos 1 vez.",
    howItWorks: "Instrucciones",
    favOnly: "Solo â­",
    resetStars: "Reiniciar â­",
    reset: "Reinicia",
    resetModalTitle: "Reiniciar progreso",
    resetConfirmBody: (lvl)=>`Â¿Quieres reiniciar el progreso del <b>${UI[getLang()].level(lvl)}</b>?`,
    resetWarn: "Esto no se puede deshacer. Los demÃ¡s niveles se conservarÃ¡n.",
    resetConfirmBtn: "SÃ­, reiniciar",
    cancel: "Cancelar",
    levelCompleteTitle: "Â¡Nivel completado!",
    levelCompleteBody: (lvl)=>`Has completado el <b>${UI[getLang()].level(lvl)}</b>. Â¿Quieres reiniciar este nivel o pasar al siguiente?`,

    nextLevelBtn: "Siguiente nivel",
    resetThisLevelBtn: "Reiniciar este nivel",
    list: "Lista de verbos",
    tenseInf: "Infinitivo",
    tensePast: "Pasado simple",
    tensePP: "Participio pasado",
    progress: "Progreso del nivel",
    correctWrong: (c,w)=>`Aciertos: ${c} Â· Errores: ${w}`,
    masteredLine: (m,t)=>`Dominados en este nivel: ${m} / ${t}`,
    question: "Pregunta:",
    next: "Siguiente",
    selectLevelToStart: "Selecciona un nivel para empezar",
    lockedLevel: "ğŸ”’ Este nivel estÃ¡ bloqueado. Completa el nivel anterior primero.",
    helpTitle: "Instrucciones",
    helpBody: `<ul class="list-disc pl-5 space-y-1">
      <li><b>N1</b>: elige el significado en catalÃ¡n.</li>
      <li><b>N2</b>: elige el infinitivo en inglÃ©s a partir del catalÃ¡n.</li>
      <li><b>N3</b>: completa el verbo en inglÃ©s con letras.</li>
      <li><b>N4</b>: elige el <b>Simple Past</b> correcto.</li>
      <li><b>N5</b>: elige el <b>Past Participle</b> correcto.</li>
      <li><b>N6</b>: rellena infinitive + simple past + past participle (puedes intentarlo las veces que haga falta).</li>
    </ul>`,
    ok: "Vale",
    lvlCompleted: (lvl)=>`Â¡Nivel ${lvl} completado!`,
    lvlCompletedBody: (lvl)=>`<p>Has acertado <b>todos</b> los verbos al menos una vez.</p><p class="mt-2">Ya puedes desbloquear el <b>Nivel ${lvl+1}</b>.</p>
      <div class="mt-4 flex flex-wrap gap-2 justify-end">
        <button id="btnResetAfterComplete" class="bg-red-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-red-700 transition">${UI[getLang()].resetThisLevelBtn}</button>
        <button id="btnNextLevel" class="bg-blue-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-blue-700 transition">${UI[getLang()].nextLevelBtn}</button>
      </div>
    `,
    gameDoneTitle: "ğŸ‰ Â¡Juego completado!",
    gameDoneBody: "<p>Has completado todos los niveles con todos los verbos.</p>",
    level: (lvl)=>`Nivel ${lvl}`,
    hintL1: "Elige el significado en catalÃ¡n:",
    hintL2: "Elige el verbo en inglÃ©s (infinitivo):",
    hintL3: "Completa el verbo en inglÃ©s con las letras:",
    hintL4: "Elige el SIMPLE PAST correcto:",
    hintL5: "Elige el PAST PARTICIPLE correcto:",
    hintL6: "Rellena <b>infinitive + simple past + past participle</b>. Puedes comprobarlo tantas veces como haga falta hasta acertar las 3.",
    good: "ğŸ˜Š Â¡Muy bien!",
    notCorrect: "ğŸ˜¢ No es correcto.",
    needAllSelects: "ğŸ˜• Selecciona una opciÃ³n en cada desplegable.",
    stillNot: "ğŸ˜¢ AÃºn no. Revisa los selectores en rojo y vuelve a probar.",
    lvl6Good: "ğŸ˜Š Â¡Muy bien! (Nivel 6 completado para este verbo)",
    pronounceTitle: "Escuchar pronunciaciÃ³n",
    letterExplain: 'Haz clic en las letras correctas. Si es correcta, se colocarÃ¡ automÃ¡ticamente en su sitio. Las incorrectas se marcarÃ¡n con una <span class="text-red-600 font-black">âœ–</span>.',
    listTitle: "Lista de verbos irregulares",
    listSubtitle: "Infinitive, Simple Past, Past Participle y significado.",
    starCol: "â­",
    meaningCol: "Significado",
    searchPh: "Buscar (infinitivo / formas / significado)...",
    close: "Cerrar",
    statsTitle: "EstadÃ­sticas",
    statsTabs: { levels: "Por nivel", difficult: "DifÃ­ciles", rounds: "Por rondas" },
    statsLevelsHead: { level:"Nivel", mastered:"Dominados", pct:"% Dominados", correct:"Aciertos", wrong:"Errores", rounds:"Rondas" },
    statsDiffEmpty: "AÃºn no hay errores registrados.",
    statsDiffErrors: "errores",
    statsRoundsHead: { level:"Nivel", round:"Ronda actual", accRound:"PrecisiÃ³n (ronda)", accTotal:"PrecisiÃ³n total", delta:"Î” mejora" },
    statsRoundsNote: "â€œRonda actualâ€ es el nÃºmero de ronda del nivel. Reiniciar inicia una nueva ronda pero guarda el histÃ³rico para ver la evoluciÃ³n.",
    colors: { label:"Colores:", easy:"FÃ¡ciles (3 iguales)", mid:"Medios (2 iguales)", hard:"DifÃ­ciles (3 diferentes)" },
    meaningHeader: "Castellano"
  },
  ka: {
    title: "áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒ˜ áƒáƒ áƒáƒ áƒ”áƒ’áƒ£áƒšáƒáƒ áƒ£áƒšáƒ˜ áƒ–áƒ›áƒœáƒ”áƒ‘áƒ˜",
  subtitle: "6 áƒ“áƒáƒœáƒ”. áƒáƒ  áƒ’áƒáƒ“áƒáƒ®áƒ•áƒ˜áƒ“áƒ”áƒ— áƒ“áƒáƒœáƒ”áƒ–áƒ” áƒ›áƒáƒœáƒáƒ›, áƒ¡áƒáƒœáƒáƒ› áƒ§áƒ•áƒ”áƒšáƒ áƒ–áƒ›áƒœáƒáƒ¡ áƒ”áƒ áƒ—áƒ®áƒ”áƒš áƒ›áƒáƒ˜áƒœáƒª áƒ¡áƒ¬áƒáƒ áƒáƒ“ áƒáƒ  áƒ£áƒáƒáƒ¡áƒ£áƒ®áƒ”áƒ‘áƒ—.",
    howItWorks: "áƒ˜áƒœáƒ¡áƒ¢áƒ áƒ£áƒ¥áƒªáƒ˜áƒ”áƒ‘áƒ˜",
    favOnly: "áƒ›áƒ®áƒáƒšáƒáƒ“ â­",
    resetStars: "â­ áƒ’áƒáƒ“áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ•áƒ",
    reset: "áƒ’áƒáƒ“áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ”áƒ—",
    resetModalTitle: "áƒ’áƒáƒ“áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ”áƒ—",
    resetConfirmBody: (lvl)=>`áƒ’áƒ˜áƒœáƒ“áƒ <b>${UI[getLang()].level(lvl)}</b>-áƒ˜áƒ¡ áƒáƒ áƒáƒ’áƒ áƒ”áƒ¡áƒ˜áƒ¡ áƒ’áƒáƒ“áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ•áƒ?`,
    resetWarn: "áƒ”áƒ¡ áƒ¥áƒ›áƒ”áƒ“áƒ”áƒ‘áƒ áƒ•áƒ”áƒ  áƒ’áƒáƒ£áƒ¥áƒ›áƒ“áƒ”áƒ‘áƒ. áƒ¡áƒ®áƒ•áƒ áƒ“áƒáƒœáƒ”áƒ”áƒ‘áƒ˜ áƒ¨áƒ”áƒœáƒáƒ áƒ©áƒ£áƒœáƒ“áƒ”áƒ‘áƒ.",
    resetConfirmBtn: "áƒ“áƒ˜áƒáƒ®, áƒ’áƒáƒ“áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ”",
    cancel: "áƒ’áƒáƒ£áƒ¥áƒ›áƒ”áƒ‘áƒ",
    levelCompleteTitle: "áƒ“áƒáƒœáƒ” áƒ“áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ£áƒšáƒ˜áƒ!",
    levelCompleteBody: (lvl)=>`áƒ¨áƒ”áƒœ áƒ“áƒáƒáƒ¡áƒ áƒ£áƒšáƒ” <b>${UI[getLang()].level(lvl)}</b>. áƒ’áƒ˜áƒœáƒ“áƒ áƒáƒ› áƒ“áƒáƒœáƒ˜áƒ¡ áƒ’áƒáƒ“áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ•áƒ áƒ—áƒ£ áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’ áƒ“áƒáƒœáƒ”áƒ–áƒ” áƒ’áƒáƒ“áƒáƒ¡áƒ•áƒšáƒ?`,

    nextLevelBtn: "áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’áƒ˜ áƒ“áƒáƒœáƒ”",
    resetThisLevelBtn: "áƒáƒ› áƒ“áƒáƒœáƒ˜áƒ¡ áƒ’áƒáƒ“áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ•áƒ",
    list: "áƒ–áƒ›áƒœáƒ”áƒ‘áƒ˜áƒ¡ áƒ¡áƒ˜áƒ",
    tenseInf: "áƒ˜áƒœáƒ¤áƒ˜áƒœáƒ˜áƒ¢áƒ˜áƒ•áƒ˜",
    tensePast: "áƒ›áƒáƒ áƒ¢áƒ˜áƒ•áƒ˜ áƒ¬áƒáƒ áƒ¡áƒ£áƒšáƒ˜",
    tensePP: "áƒ¬áƒáƒ áƒ¡áƒ£áƒšáƒ˜ áƒ›áƒ˜áƒ›áƒ¦áƒ”áƒáƒ‘áƒ",
    progress: "áƒ“áƒáƒœáƒ˜áƒ¡ áƒáƒ áƒáƒ’áƒ áƒ”áƒ¡áƒ˜",
    correctWrong: (c,w)=>`áƒ¡áƒ¬áƒáƒ áƒ˜: ${c} Â· áƒ¨áƒ”áƒªáƒ“áƒáƒ›áƒ: ${w}`,
    masteredLine: (m,t)=>`áƒáƒ› áƒ“áƒáƒœáƒ”áƒ–áƒ” áƒ“áƒáƒ›áƒáƒ®áƒ¡áƒáƒ•áƒ áƒ”áƒ‘áƒ£áƒšáƒ˜: ${m} / ${t}`,
    question: "áƒ™áƒ˜áƒ—áƒ®áƒ•áƒ:",
    next: "áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’áƒ˜",
    selectLevelToStart: "áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ“áƒáƒœáƒ” áƒ“áƒáƒ¡áƒáƒ¬áƒ§áƒ”áƒ‘áƒáƒ“",
    lockedLevel: "ğŸ”’ áƒ”áƒ¡ áƒ“áƒáƒœáƒ” áƒ“áƒáƒ‘áƒšáƒáƒ™áƒ˜áƒšáƒ˜áƒ. áƒ¯áƒ”áƒ  áƒ“áƒáƒáƒ¡áƒ áƒ£áƒšáƒ” áƒ¬áƒ˜áƒœáƒ áƒ“áƒáƒœáƒ”.",
    helpTitle: "áƒ˜áƒœáƒ¡áƒ¢áƒ áƒ£áƒ¥áƒªáƒ˜áƒ”áƒ‘áƒ˜",
    helpBody: `<ul class="list-disc pl-5 space-y-1">
      <li><b>N1</b>: áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ áƒ™áƒáƒ¢áƒáƒšáƒáƒœáƒ£áƒ áƒáƒ“.</li>
      <li><b>N2</b>: áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒ˜ áƒ˜áƒœáƒ¤áƒ˜áƒœáƒ˜áƒ¢áƒ˜áƒ•áƒ˜ áƒ™áƒáƒ¢áƒáƒšáƒáƒœáƒ£áƒ áƒ˜áƒ“áƒáƒœ.</li>
      <li><b>N3</b>: áƒ¨áƒ”áƒáƒ“áƒ’áƒ˜áƒœáƒ” áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒ˜ áƒ–áƒ›áƒœáƒ áƒáƒ¡áƒáƒ”áƒ‘áƒ˜áƒ—.</li>
      <li><b>N4</b>: áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ¡áƒ¬áƒáƒ áƒ˜ <b>Simple Past</b>.</li>
      <li><b>N5</b>: áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ¡áƒ¬áƒáƒ áƒ˜ <b>Past Participle</b>.</li>
      <li><b>N6</b>: áƒ¨áƒ”áƒáƒ•áƒ¡áƒ” infinitive + simple past + past participle (áƒ¨áƒ”áƒ’áƒ˜áƒ«áƒšáƒ˜áƒ áƒ áƒáƒ›áƒ“áƒ”áƒœáƒ¯áƒ”áƒ áƒáƒª áƒ’áƒ˜áƒœáƒ“áƒ áƒ¡áƒªáƒáƒ“áƒ).</li>
    </ul>`,
    ok: "áƒ™áƒáƒ áƒ’áƒ˜",
    lvlCompleted: (lvl)=>`áƒ“áƒáƒœáƒ” ${lvl} áƒ“áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ£áƒšáƒ˜áƒ!`,
    lvlCompletedBody: (lvl)=>`<p>áƒ§áƒ•áƒ”áƒšáƒ áƒ–áƒ›áƒœáƒ áƒ›áƒ˜áƒœáƒ˜áƒ›áƒ£áƒ› áƒ”áƒ áƒ—áƒ®áƒ”áƒš áƒ¡áƒ¬áƒáƒ áƒáƒ“ áƒ’áƒáƒ›áƒáƒ˜áƒªáƒáƒœáƒ˜.</p><p class="mt-2">áƒáƒ®áƒšáƒ áƒ¨áƒ”áƒ’áƒ˜áƒ«áƒšáƒ˜áƒ áƒ’áƒáƒ®áƒ¡áƒœáƒ <b>áƒ“áƒáƒœáƒ” ${lvl+1}</b>.</p>
      <div class="mt-4 flex flex-wrap gap-2 justify-end">
        <button id="btnResetAfterComplete" class="bg-red-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-red-700 transition">${UI[getLang()].resetThisLevelBtn}</button>
        <button id="btnNextLevel" class="bg-blue-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-blue-700 transition">${UI[getLang()].nextLevelBtn}</button>
      </div>
    `,
    gameDoneTitle: "ğŸ‰ áƒ—áƒáƒ›áƒáƒ¨áƒ˜ áƒ“áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ£áƒšáƒ˜áƒ!",
    gameDoneBody: "<p>áƒ§áƒ•áƒ”áƒšáƒ áƒ“áƒáƒœáƒ” áƒ“áƒ áƒ§áƒ•áƒ”áƒšáƒ áƒ–áƒ›áƒœáƒ áƒ“áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ£áƒšáƒ˜áƒ.</p>",
    level: (lvl)=>`áƒ“áƒáƒœáƒ” ${lvl}`,
    hintL1: "áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ áƒ™áƒáƒ¢áƒáƒšáƒáƒœáƒ£áƒ áƒáƒ“:",
    hintL2: "áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ–áƒ›áƒœáƒ áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒáƒ“ (áƒ˜áƒœáƒ¤áƒ˜áƒœáƒ˜áƒ¢áƒ˜áƒ•áƒ˜):",
    hintL3: "áƒ¨áƒ”áƒáƒ“áƒ’áƒ˜áƒœáƒ” áƒ–áƒ›áƒœáƒ áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒáƒ“ áƒáƒ¡áƒáƒ”áƒ‘áƒ˜áƒ—:",
    hintL4: "áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ¡áƒ¬áƒáƒ áƒ˜ SIMPLE PAST:",
    hintL5: "áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ¡áƒ¬áƒáƒ áƒ˜ PAST PARTICIPLE:",
    hintL6: "áƒ¨áƒ”áƒáƒ•áƒ¡áƒ” <b>infinitive + simple past + past participle</b>. áƒ¨áƒ”áƒáƒ›áƒáƒ¬áƒ›áƒ” áƒ áƒáƒ›áƒ“áƒ”áƒœáƒ¯áƒ”áƒ áƒáƒª áƒ’áƒ˜áƒœáƒ“áƒ, áƒ¡áƒáƒœáƒáƒ› áƒ¡áƒáƒ›áƒ˜áƒ•áƒ” áƒ¡áƒ¬áƒáƒ áƒ˜áƒ.",
    good: "ğŸ˜Š áƒ™áƒáƒ áƒ’áƒ˜!",
    notCorrect: "ğŸ˜¢ áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜áƒ.",
    needAllSelects: "ğŸ˜• áƒ—áƒ˜áƒ—áƒáƒ”áƒ£áƒš áƒ©áƒáƒ›áƒáƒ¡áƒáƒ¨áƒšáƒ”áƒšáƒ¨áƒ˜ áƒáƒ˜áƒ áƒ©áƒ˜áƒ” áƒ•áƒáƒ áƒ˜áƒáƒœáƒ¢áƒ˜.",
    stillNot: "ğŸ˜¢ áƒ¯áƒ”áƒ  áƒáƒ áƒ. áƒ’áƒáƒ“áƒáƒáƒ›áƒáƒ¬áƒ›áƒ” áƒ¬áƒ˜áƒ—áƒšáƒáƒ“ áƒ›áƒáƒœáƒ˜áƒ¨áƒœáƒ£áƒšáƒ˜ áƒ“áƒ áƒ¡áƒªáƒáƒ“áƒ” áƒ—áƒáƒ•áƒ˜áƒ“áƒáƒœ.",
    lvl6Good: "ğŸ˜Š áƒ™áƒáƒ áƒ’áƒ˜! (áƒ“áƒáƒœáƒ” 6 áƒ“áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ£áƒšáƒ˜áƒ áƒáƒ› áƒ–áƒ›áƒœáƒ˜áƒ¡áƒ—áƒ•áƒ˜áƒ¡)",
    pronounceTitle: "áƒ’áƒáƒ›áƒáƒ—áƒ¥áƒ›áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ›áƒ”áƒœáƒ",
    letterExplain: 'áƒ“áƒáƒáƒ­áƒ˜áƒ áƒ” áƒ¡áƒ¬áƒáƒ  áƒáƒ¡áƒáƒ”áƒ‘áƒ¡. áƒ—áƒ£ áƒ¡áƒ¬áƒáƒ áƒ˜áƒ, áƒáƒ•áƒ¢áƒáƒ›áƒáƒ¢áƒ£áƒ áƒáƒ“ áƒ“áƒáƒ“áƒ’áƒ”áƒ‘áƒ áƒ—áƒáƒ•áƒ˜áƒ¡ áƒáƒ“áƒ’áƒ˜áƒšáƒ–áƒ”. áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒáƒ¡áƒáƒ”áƒ‘áƒ˜ áƒ›áƒáƒœáƒ˜áƒ¨áƒœáƒ“áƒ”áƒ‘áƒ <span class="text-red-600 font-black">âœ–</span>-áƒ˜áƒ—.',
    listTitle: "áƒáƒ áƒáƒ áƒ”áƒ’áƒ£áƒšáƒáƒ áƒ£áƒšáƒ˜ áƒ–áƒ›áƒœáƒ”áƒ‘áƒ˜áƒ¡ áƒ¡áƒ˜áƒ",
    listSubtitle: "Infinitive, Simple Past, Past Participle áƒ“áƒ áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ.",
    starCol: "â­",
    meaningCol: "áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ",
    searchPh: "áƒ«áƒ”áƒ‘áƒœáƒ (infinitive / forms / meaning)...",
    close: "áƒ“áƒáƒ®áƒ£áƒ áƒ•áƒ",
    statsTitle: "áƒ¡áƒ¢áƒáƒ¢áƒ˜áƒ¡áƒ¢áƒ˜áƒ™áƒ",
    statsTabs: { levels: "áƒ“áƒáƒœáƒ”áƒ”áƒ‘áƒ˜áƒ—", difficult: "áƒ áƒ—áƒ£áƒšáƒ”áƒ‘áƒ˜", rounds: "áƒ áƒáƒœáƒ“áƒ”áƒ‘áƒ˜áƒ—" },
    statsLevelsHead: { level:"áƒ“áƒáƒœáƒ”", mastered:"áƒ“áƒáƒ›áƒáƒ®áƒ¡áƒáƒ•áƒ áƒ”áƒ‘áƒ£áƒšáƒ˜", pct:"% áƒ“áƒáƒ›áƒáƒ®áƒ¡áƒáƒ•áƒ áƒ”áƒ‘áƒ£áƒšáƒ˜", correct:"áƒ¡áƒ¬áƒáƒ áƒ˜", wrong:"áƒ¨áƒ”áƒªáƒ“áƒáƒ›áƒ", rounds:"áƒ áƒáƒœáƒ“áƒ”áƒ‘áƒ˜" },
    statsDiffEmpty: "áƒ¯áƒ”áƒ áƒ¯áƒ”áƒ áƒáƒ‘áƒ˜áƒ— áƒ¨áƒ”áƒªáƒ“áƒáƒ›áƒ”áƒ‘áƒ˜ áƒáƒ  áƒáƒ áƒ˜áƒ¡.",
    statsDiffErrors: "áƒ¨áƒ”áƒªáƒ“áƒáƒ›áƒ",
    statsRoundsHead: { level:"áƒ“áƒáƒœáƒ”", round:"áƒ›áƒ˜áƒ›áƒ“áƒ˜áƒœáƒáƒ áƒ” áƒ áƒáƒœáƒ“áƒ", accRound:"áƒ¡áƒ˜áƒ–áƒ£áƒ¡áƒ¢áƒ” (áƒ áƒáƒœáƒ“áƒ)", accTotal:"áƒ¡áƒ˜áƒ–áƒ£áƒ¡áƒ¢áƒ” áƒ¡áƒ£áƒš", delta:"Î” áƒ’áƒáƒ£áƒ›áƒ¯áƒáƒ‘áƒ”áƒ¡áƒ”áƒ‘áƒ" },
    statsRoundsNote: "â€áƒ›áƒ˜áƒ›áƒ“áƒ˜áƒœáƒáƒ áƒ” áƒ áƒáƒœáƒ“áƒâ€œ áƒáƒ áƒ˜áƒ¡ áƒáƒ› áƒ“áƒáƒœáƒ˜áƒ¡ áƒ áƒáƒœáƒ“áƒ˜áƒ¡ áƒœáƒáƒ›áƒ”áƒ áƒ˜. áƒ’áƒáƒ“áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ•áƒ áƒ˜áƒ¬áƒ§áƒ”áƒ‘áƒ¡ áƒáƒ®áƒáƒš áƒ áƒáƒœáƒ“áƒáƒ¡, áƒ›áƒáƒ’áƒ áƒáƒ› áƒ˜áƒœáƒáƒ®áƒáƒ•áƒ¡ áƒ˜áƒ¡áƒ¢áƒáƒ áƒ˜áƒáƒ¡ áƒáƒ áƒáƒ’áƒ áƒ”áƒ¡áƒ˜áƒ¡ áƒ¡áƒáƒœáƒáƒ®áƒáƒ•áƒáƒ“.",
    colors: { label:"áƒ¤áƒ”áƒ áƒ”áƒ‘áƒ˜:", easy:"áƒ›áƒáƒ áƒ¢áƒ˜áƒ•áƒ˜ (3 áƒ”áƒ áƒ—áƒœáƒáƒ˜áƒ áƒ˜)", mid:"áƒ¡áƒáƒ¨áƒ£áƒáƒšáƒ (2 áƒ”áƒ áƒ—áƒœáƒáƒ˜áƒ áƒ˜)", hard:"áƒ áƒ—áƒ£áƒšáƒ˜ (3 áƒ’áƒáƒœáƒ¡áƒ®áƒ•áƒáƒ•áƒ”áƒ‘áƒ£áƒšáƒ˜)" },
    meaningHeader: "áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ"
  }
};
function getLang(){
  const saved = localStorage.getItem(LANG_KEY);
  return (saved==="ca"||saved==="es"||saved==="ka") ? saved : "ca";
}
function setLang(lang){
  if(!(lang==="ca"||lang==="es"||lang==="ka")) lang="ca";
  localStorage.setItem(LANG_KEY, lang);
}
function t(key){
  const lang = getLang();
  return UI[lang][key] ?? UI.ca[key] ?? key;
}
function meaningForLang(v){
  const lang = getLang();
  if(lang==="es") return (v.es || v.ca || v.inf || "").trim();
  if(lang==="ka") return (v.ka || v.es || v.ca || v.inf || "").trim();
  return displayCa(v);
}

const STORE_KEY = "irregular_verbs_game_v4";

const els = {
  levelBar: document.getElementById("levelBar"),
  levelBtns: () => Array.from(document.querySelectorAll(".levelBtn")),
  btnReset: document.getElementById("btnReset"),
  btnList: document.getElementById("btnList"),
  btnHelp: document.getElementById("btnHelp"),
  btnStats: document.getElementById("btnStats"),
  btnSpeak: document.getElementById("btnSpeak"),
  btnStar: document.getElementById("btnStar"),
  studyControls: document.getElementById("studyControls"),
  chkFavOnly: document.getElementById("chkFavOnly"),
  lblFavOnly: document.getElementById("lblFavOnly"),
  btnResetStars: document.getElementById("btnResetStars"),
  quizHeaderGrid: document.getElementById("quizHeaderGrid"),
  quizArea: document.getElementById("quizArea"),
    mcqWrap: document.getElementById("answers"),
  mcqOptions: document.getElementById("answers"),
levelTitle: document.getElementById("levelTitle"),
  questionText: document.getElementById("questionText"),
  questionHint: document.getElementById("questionHint"),
  answers: document.getElementById("answers"),
  feedback: document.getElementById("feedback"),
  btnNext: document.getElementById("btnNext"),
    levelHeaderLeft: document.getElementById("levelHeaderLeft"),
    quizFooter: document.getElementById("quizFooter"),
    progressSection: document.getElementById("progressSection"),
  qIndex: document.getElementById("qIndex"),
  qTotal: document.getElementById("qTotal"),
  progressBar: document.getElementById("progressBar"),
  progressPct: document.getElementById("progressPct"),
  progressRemain: document.getElementById("progressRemain"),
  scoreLine: document.getElementById("scoreLine"),
  masterLine: document.getElementById("masterLine"),
  modal: document.getElementById("modal"),
  modalTitle: document.getElementById("modalTitle"),
  modalBody: document.getElementById("modalBody"),
  modalClose: document.getElementById("modalClose"),
  modalOk: document.getElementById("modalOk"),
  level6Area: document.getElementById("level6Area"),
    selInf: document.getElementById("selInf"),
  selPast: document.getElementById("selPast"),
  selPP: document.getElementById("selPP"),
  btnSpeakInf: document.getElementById("btnSpeakInf"),
  btnSpeakPast: document.getElementById("btnSpeakPast"),
  btnSpeakPP: document.getElementById("btnSpeakPP"),
// nivell 3
  level3Letters: document.getElementById("level3Letters"),
  letterSlots: document.getElementById("letterSlots"),
  letterBank: document.getElementById("letterBank"),
  btnL3Audio: document.getElementById("btnL3Audio"),
  btnL3Help: document.getElementById("btnL3Help"),
  tenseInf: document.getElementById("tenseInf"),
  tensePast: document.getElementById("tensePast"),
  tensePP: document.getElementById("tensePP"),
  btnCheckLevel6: document.getElementById("btnCheckLevel6"),
  tenseFilters: document.getElementById('tenseFilters'),
  tenseChks: Array.from(document.querySelectorAll('.tenseChk')),
  tenseInf: document.getElementById('tenseInf'),
  tensePast: document.getElementById('tensePast'),
  tensePP: document.getElementById('tensePP'),
  tenseInfLbl: document.getElementById('tenseInfLbl'),
  tensePastLbl: document.getElementById('tensePastLbl'),
  tensePPLbl: document.getElementById('tensePPLbl')
};

/* --- Mobile layout helper: split question text into main + parentheses spans --- */
function normalizeQuestionText(){
  const qt = els.questionText;
  if(!qt) return;
  if(qt.querySelector(".qMain")) return;

  // Capture existing nodes
  let main = "";
  let paren = "";
  qt.childNodes.forEach(n=>{
    if(n.nodeType === 3){ main += n.textContent; }
    else if(n.nodeType === 1){
      if(n.classList.contains("tenseSmall")) paren = n.textContent;
      else main += n.textContent;
    }
  });

  main = (main || "").replace(/\s+/g," ").trim();
  paren = (paren || "").trim();

  qt.innerHTML = "";
  const sMain = document.createElement("span");
  sMain.className = "qMain";
  sMain.textContent = main || "";
  qt.appendChild(sMain);

  if(paren){
    const sParen = document.createElement("span");
    sParen.className = "qParen tenseSmall";
    sParen.textContent = paren;
    qt.appendChild(sParen);
  }
}



// FIX49: Move tense filter box to the LEFT under "Nivell" header (only in Level 3)
let __tenseFiltersHome = null;
function placeTenseFilters(lvl){
  const tf = els.tenseFilters;
  if(!tf) return;
  if(!__tenseFiltersHome) __tenseFiltersHome = tf.parentElement;

  const titleEl = document.getElementById("levelTitle");
  const resetBtn = document.getElementById("btnReset");
  let topRow = document.getElementById("lvlTopRow");

  if(lvl===3){
    // Make the left header a vertical stack
    els.levelHeaderLeft.classList.add("lvl3LeftCol");

    tf.classList.remove("hidden");

    // Ensure a top row that keeps "Nivell 3" + "Reinicia" side by side
    if(!topRow){
      topRow = document.createElement("div");
      topRow.id = "lvlTopRow";
      els.levelHeaderLeft.insertBefore(topRow, els.levelHeaderLeft.firstChild);
    }
    if(titleEl && titleEl.parentElement !== topRow) topRow.appendChild(titleEl);
    if(resetBtn && resetBtn.parentElement !== topRow) topRow.appendChild(resetBtn);

    // FIX: En mÃ²bil, colÂ·loca els filtres dins del quizHeaderGrid directament
    const isMobile = window.matchMedia && window.matchMedia("(max-width: 640px)").matches;
    const targetParent = isMobile ? els.quizHeaderGrid : els.levelHeaderLeft;
    
    if(tf.parentElement !== targetParent) targetParent.appendChild(tf);
    if(!isMobile && els.levelHeaderLeft.lastElementChild !== tf) els.levelHeaderLeft.appendChild(tf);

  } else {
    els.levelHeaderLeft.classList.remove("lvl3LeftCol");

    if(__tenseFiltersHome && tf.parentElement !== __tenseFiltersHome){
      __tenseFiltersHome.appendChild(tf);
    }
    tf.classList.add("hidden");

    if(topRow){
      if(titleEl) els.levelHeaderLeft.insertBefore(titleEl, els.levelHeaderLeft.firstChild);
      if(resetBtn) els.levelHeaderLeft.insertBefore(resetBtn, titleEl ? titleEl.nextSibling : els.levelHeaderLeft.firstChild);
      topRow.remove();
    }
  }
}


// FIX23: Toggle Level 3 mode (hide top speak button + compact layout)
// FIX26: Toggle body classes by current level (for CSS behaviors)
function applyLevelMode(){
  const lvl = state && state.currentLevel ? state.currentLevel : 0;
  document.body.classList.toggle('lvl2', lvl===2);
  document.body.classList.toggle('lvl3', lvl===3);
  try{ placeTenseFilters(lvl); }catch(e){}
  document.body.classList.toggle('lvl6', lvl===6);
  // hide/show speak button safely via updateSpeakButton
  try{ updateSpeakButton(state.current);
  // FIX40: auto audio for question
  try{ if(isAutoAudio() && els.btnSpeak && !els.btnSpeak.classList.contains('hidden')) els.btnSpeak.click(); }catch(e){} }catch(e){}
}


function initialState() {
  const progress = {};
  const retries = {};
  const stars = {};
  const favOnly = {};
  for (const lvl of [1,2,3,4,5,6]) {
    progress[lvl] = { mastered: {}, correct: 0, wrong: 0 };
    retries[lvl] = [];
    stars[lvl] = {};      // questionKey -> boolean (true=include)
    favOnly[lvl] = false; // per-level filter (false=all, true=only starred)
  }
  return {
    tenseSel: { inf: true, past: true, pp: true },
    currentLevel: null,
    queue: [],
    current: null,
    answered: false,
    progress,
    retries,
    stars,
    favOnly,
    rounds: { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1 },
    errByKey: { 1:{}, 2:{}, 3:{}, 4:{}, 5:{}, 6:{} },
    // Historical per-level rounds (archived on reset). Each item: {round, endedAt, correct, wrong, mastered, errByKey}
    history: { 1:[], 2:[], 3:[], 4:[], 5:[], 6:[] },
    qPos: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 },
    levelCompleteShown: { 1:false, 2:false, 3:false, 4:false, 5:false, 6:false }
  };
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORE_KEY);
    if(!raw) return initialState();
    const st = JSON.parse(raw);
    if(!st.progress) st.progress = initialState().progress;
    if(!st.retries) st.retries = initialState().retries;
    if(!st.qPos) st.qPos = initialState().qPos;
    if(!st.levelCompleteShown) st.levelCompleteShown = initialState().levelCompleteShown;
    if(!st.tenseSel) st.tenseSel = initialState().tenseSel;
    if(!st.stars) st.stars = initialState().stars;
    if(!st.favOnly) st.favOnly = initialState().favOnly;
    if(!st.rounds) st.rounds = initialState().rounds;
    if(!st.errByKey) st.errByKey = initialState().errByKey;
    if(!st.history) st.history = initialState().history;
    for (const lvl of [1,2,3,4,5,6]) {
      st.progress[lvl] = st.progress[lvl] || { mastered: {}, correct: 0, wrong: 0 };
      st.progress[lvl].mastered = st.progress[lvl].mastered || {};
      st.progress[lvl].correct = st.progress[lvl].correct || 0;
      st.progress[lvl].wrong = st.progress[lvl].wrong || 0;
      st.retries[lvl] = Array.isArray(st.retries[lvl]) ? st.retries[lvl] : [];
      st.stars[lvl] = st.stars[lvl] || {};
      st.favOnly[lvl] = !!st.favOnly[lvl];
      st.rounds[lvl] = (st.rounds && st.rounds[lvl]) ? st.rounds[lvl] : 1;
      st.errByKey[lvl] = (st.errByKey && st.errByKey[lvl]) ? st.errByKey[lvl] : {};
      if(!st.history) st.history = initialState().history;
      st.history[lvl] = Array.isArray(st.history[lvl]) ? st.history[lvl] : [];
    }
    // Sempre iniciem sense nivell seleccionat (perÃ² mantenim el progrÃ©s guardat)
    st.currentLevel = null;
    st.queue = [];
    st.current = null;
    st.answered = false;
    return st;
  } catch(e) {
    return initialState();
  }
}

function syncTopButtonsWidth(){
  const a = document.getElementById("btnHelp");
  const b = document.getElementById("btnList");
  if(!a || !b) return;

  // Measure a "reference" width using the Georgian word for Instructions (same font/padding),
  // so buttons keep the same width across languages.
  const refText = (UI && UI.ka && UI.ka.howItWorks) ? UI.ka.howItWorks : "áƒ˜áƒœáƒ¡áƒ¢áƒ áƒ£áƒ¥áƒªáƒ˜áƒ”áƒ‘áƒ˜";

  // Temporarily reset to natural width
  a.style.width = "auto";
  b.style.width = "auto";

  const probe = document.createElement("span");
  probe.textContent = refText;
  probe.style.position = "absolute";
  probe.style.visibility = "hidden";
  probe.style.whiteSpace = "nowrap";
  // Copy key computed styles from button A so measurement matches
  const cs = window.getComputedStyle(a);
  probe.style.font = cs.font;
  probe.style.fontSize = cs.fontSize;
  probe.style.fontFamily = cs.fontFamily;
  probe.style.fontWeight = cs.fontWeight;
  probe.style.letterSpacing = cs.letterSpacing;
  probe.style.paddingLeft = cs.paddingLeft;
  probe.style.paddingRight = cs.paddingRight;
  probe.style.borderLeftWidth = cs.borderLeftWidth;
  probe.style.borderRightWidth = cs.borderRightWidth;
  probe.style.boxSizing = cs.boxSizing;

  document.body.appendChild(probe);
  const refW = Math.ceil(probe.getBoundingClientRect().width);
  probe.remove();

  // Ensure we never truncate longer labels (take max with current widest)
  const currentW = Math.ceil(Math.max(a.getBoundingClientRect().width, b.getBoundingClientRect().width));
  const w = Math.max(refW, currentW);

  a.style.width = `${w}px`;
  b.style.width = `${w}px`;
}

function applyLanguage(){
  const lang = getLang();
  document.documentElement.lang = lang;
  const sel = document.getElementById("langSel");
  if(sel && sel.value !== lang) sel.value = lang;

  // Header texts
  const titleEl = document.getElementById("appTitle");
  const subEl = document.getElementById("appSubtitle");
  if(titleEl) titleEl.textContent = UI[lang].title;
  if(subEl) subEl.textContent = UI[lang].subtitle;

  const lblProg = document.getElementById("lblProgress");
  if(lblProg) lblProg.textContent = UI[lang].progress;

  const lblQ = document.getElementById("lblQuestion");
  if(lblQ) lblQ.textContent = UI[lang].question;

  // Buttons
  if(els.btnHelp) els.btnHelp.textContent = UI[lang].howItWorks;
  if(els.btnReset) els.btnReset.textContent = UI[lang].reset;
  if(els.btnList) els.btnList.textContent = UI[lang].list;
  if(els.btnNext) els.btnNext.textContent = UI[lang].next;
  if(els.btnSpeak) els.btnSpeak.title = UI[lang].pronounceTitle;

  const explain = document.getElementById("lblLetterExplain");
  if(explain) explain.innerHTML = UI[lang].letterExplain;

  // Modal button
  if(els.modalOk) els.modalOk.textContent = UI[lang].ok;

  // If we are on a question, re-render current question (without advancing)
  if(state && state.current){
    // Keep answered state; just re-render prompt/labels
    els.levelTitle.textContent = UI[lang].level(state.currentLevel);
    if(!state.answered){
      // rebuild current question fully for correct language
      const cur = state.current;
      clearAnswers();
      setFeedback("");
      setNextEnabled(false);
      if(state.currentLevel===1) buildLevel1(cur);
      else if(state.currentLevel===2) buildLevel2(cur);
      else if(state.currentLevel===3) buildLevel3(cur);
      else if(state.currentLevel===4) buildLevel4(cur);
      else if(state.currentLevel===5) buildLevel5(cur);
      else if(state.currentLevel===6) buildLevel6(cur);
    } else {
      // Only update question text/ hint
      if(state.currentLevel===1) { els.questionText.textContent = state.current.inf; els.questionHint.textContent = UI[lang].hintL1; }
      if(state.currentLevel===2) { els.questionText.textContent = meaningForLang(state.current); els.questionHint.textContent = UI[lang].hintL2; }
      if(state.currentLevel===3) { els.questionText.textContent = meaningForLang(state.current); els.questionHint.textContent = UI[lang].hintL3; }
      if(state.currentLevel===4) { els.questionHint.textContent = UI[lang].hintL4; }
      if(state.currentLevel===5) { els.questionHint.textContent = UI[lang].hintL5; }
      if(state.currentLevel===6) { els.questionHint.innerHTML = UI[lang].hintL6; }
    }
  } else {
    els.levelTitle.textContent = "";
    els.questionText.textContent = UI[lang].selectLevelToStart;
    els.questionHint.textContent = "";
  }

  // Stats modal UI
  const st = document.getElementById("statsTitle");
  if(st) st.textContent = UI[lang].statsTitle || "ğŸ“Š";
  const stCloseBtn = document.getElementById("statsCloseBtn");
  if(stCloseBtn) stCloseBtn.textContent = UI[lang].close;
  const stCloseX = document.getElementById("statsCloseX");
  if(stCloseX) stCloseX.setAttribute("aria-label", UI[lang].close);
  document.querySelectorAll(".statsTabBtn").forEach(b=>{
    const tab = b.dataset.tab;
    const map = UI[lang].statsTabs || {};
    if(map && map[tab]) b.textContent = map[tab];
  });

  syncTopButtonsWidth();

  syncTenseFiltersUI();
  syncStudyControlsUI();
  syncStarUI();
  updateStatsUI();
  try{ if(state && state.current) updateSpeakButton(state.current);
  // FIX40: auto audio for question
  try{ if(isAutoAudio() && els.btnSpeak && !els.btnSpeak.classList.contains('hidden')) els.btnSpeak.click(); }catch(e){} }catch(e){}
}

function syncTenseFiltersUI(){
  // Only visible on level 3
  const lvl = state.currentLevel;
  if(!els.tenseFilters) return;
  if(lvl===3){
    els.tenseFilters.classList.remove("hidden");
  }else{
    els.tenseFilters.classList.add("hidden");
  }

  // labels (translated)
  els.tenseInfLbl.textContent = UI[getLang()].tenseInf;
  els.tensePastLbl.textContent = UI[getLang()].tensePast;
  els.tensePPLbl.textContent = UI[getLang()].tensePP;

  // sync checked states
  const sel = state.tenseSel || {inf:true,past:false,pp:false};
  els.tenseInf.checked = !!sel.inf;
  els.tensePast.checked = !!sel.past;
  els.tensePP.checked = !!sel.pp;
}

function syncStudyControlsUI(){
  const lvl = state.currentLevel;
  if(!els.studyControls) return;
  if(lvl){
    els.studyControls.classList.remove("hidden");
    els.lblFavOnly.textContent = UI[getLang()].favOnly;
    els.btnResetStars.textContent = UI[getLang()].resetStars;
    els.chkFavOnly.checked = isFavOnly(lvl);
    // enable reset button only if any question is unstarred (false stored)
    const map = (state.stars && state.stars[lvl]) ? state.stars[lvl] : {};
    const hasFalse = Object.values(map).some(v => v === false);
    els.btnResetStars.disabled = !hasFalse;
  } else {
    els.studyControls.classList.add("hidden");
  }
}
function syncStarUI(){
  const lvl = state.currentLevel;
  if(!els.btnStar) return;
  if(!lvl || !state.currentKey){
    els.btnStar.classList.add("hidden");
    els.btnStar.setAttribute("aria-pressed","true");
    els.btnStar.textContent = "â­";
    return;
  }
  els.btnStar.classList.remove("hidden");
  const starred = isStarred(lvl, state.currentKey);
  els.btnStar.setAttribute("aria-pressed", starred ? "true" : "false");
  els.btnStar.textContent = starred ? "â­" : "â˜†";
}

// tense filter listeners (level 3)
(function initTenseFilters(){
  if(!els.tenseChks || !els.tenseChks.length) return;
  els.tenseChks.forEach(chk=>{
    chk.addEventListener("change", ()=>{
      // update state
      const t = chk.dataset.tense;
      state.tenseSel = state.tenseSel || {inf:true,past:false,pp:false}
// FIX23: keep Level 3 speak hidden after language change
try{ applyLevelMode(); }catch(e){};
      state.tenseSel[t] = chk.checked;

      // enforce at least one active (cannot leave all unchecked)
      const any = Object.values(state.tenseSel).some(Boolean);
      if(!any){
        state.tenseSel.inf = true;
        els.tenseInf.checked = true;
      }

      saveState();

      // Level 3 behavior:
      // - Changing filters must NOT change the current question unless it becomes invalid.
      // - Enabling extra filters only expands the future pool.
      if(state.currentLevel===3){
        // refresh pool for future questions / totals
        state.queue = buildQueueForLevel(3);
        state.retries[3] = state.retries[3] || [];

        const active = getActiveTenses();
        const curTense = state.currentTense || "inf";
        const hasCurrent = !!state.current;

        // If current question's tense is still allowed, keep it
        if(hasCurrent && active.includes(curTense)){
          saveState();
          updateStatsUI();
          // keep current screen as-is
          return;
        }

        // Otherwise, we must move to a valid question
        if(hasCurrent){
          state.current = null;
          state.answered = false;
        }
        saveState();
        nextQuestion();
        return;
      }

      // other levels
      updateStatsUI();
    });});

  // Study personalization (stars)
  if(els.btnStar){
    els.btnStar.addEventListener("click", ()=>{
      const lvl = state.currentLevel;
      if(!lvl || !state.currentKey) return;

      const cur = isStarred(lvl, state.currentKey);

      // Rule: you can only DISABLE â­ after answering that item correctly at least once.
      // (Re-enabling is always allowed.)
      if(cur === true){
        const masteredObj = (state.progress && state.progress[lvl] && state.progress[lvl].mastered) ? state.progress[lvl].mastered : {};
        const isMastered = !!masteredObj[state.currentKey];
        if(!isMastered){
          // small visual feedback (no modal noise)
          els.btnStar.classList.add("shake");
          setTimeout(()=>els.btnStar.classList.remove("shake"), 300);
          return;
        }
      }

      setStarred(lvl, state.currentKey, !cur);

      // Note: 'NomÃ©s â­' affects the NEXT round only.
      // Changing â­ during a round does not remove items already in the current pool.

      // Auto-reset if none starred remains (always)
      ensureStarsNotEmpty(lvl);
      saveState();
      syncStarUI();
      syncStudyControlsUI();
      // do NOT change the current question
    });
  }
  if(els.chkFavOnly){
    els.chkFavOnly.addEventListener("change", ()=>{
      const lvl = state.currentLevel;
      if(!lvl) return;
      setFavOnly(lvl, els.chkFavOnly.checked);
      saveState();
      syncStudyControlsUI();

      // Update counters/progress immediately when toggling "NomÃ©s â­"
      try{
        // Question total (does not rebuild the current queue mid-round)
        const baseTotal = (getPracticeTotal(lvl) || getLevelTotal(lvl));
        if(els.qTotal) els.qTotal.textContent = String(baseTotal);
      }catch(e){}
      try{ updateProgress(lvl); }catch(e){}
      try{ updateStatsUI(); }catch(e){}
    });
  }
  if(els.btnResetStars){
    els.btnResetStars.addEventListener("click", ()=>{
      const lvl = state.currentLevel;
      if(!lvl) return;
      resetAllStarsForLevel(lvl);
      ensureStarsNotEmpty(lvl);
      saveState();
      syncStarUI();
      syncStudyControlsUI();
      // refresh pool for future
      state.queue = buildQueueForLevel(lvl);
  state.roundSnap = state.roundSnap || {};
  state.roundSnap[lvl] = { favOnly: isFavOnly(lvl), tenses: (lvl===3 ? getActiveTenses().slice() : null), total: state.queue.length };
      saveState();
      updateStatsUI();
    });
  }

})();



let state = loadState();
function saveState(){ localStorage.setItem(STORE_KEY, JSON.stringify(state)); }

// --- Stats helpers ---
function ensureRound(lvl){
  if(!state.rounds) state.rounds = {1:1,2:1,3:1,4:1,5:1,6:1};
  if(!state.rounds[lvl]) state.rounds[lvl] = 1;
}
function ensureHistory(){
  if(!state.history) state.history = {1:[],2:[],3:[],4:[],5:[],6:[]};
  for(const lvl of [1,2,3,4,5,6]){
    if(!Array.isArray(state.history[lvl])) state.history[lvl] = [];
  }
}
function noteWrong(lvl, key){
  if(!key) return;
  if(!state.errByKey) state.errByKey = {1:{},2:{},3:{},4:{},5:{},6:{}};
  if(!state.errByKey[lvl]) state.errByKey[lvl] = {};
  state.errByKey[lvl][key] = (state.errByKey[lvl][key]||0) + 1;
}
function archiveRoundIfAny(lvl){
  // Save current round stats into history before resetting (so stats modal can show evolution).
  ensureRound(lvl);
  ensureHistory();

  const prog = state.progress && state.progress[lvl] ? state.progress[lvl] : {mastered:{},correct:0,wrong:0};
  const mastered = Object.keys(prog.mastered||{}).length;
  const c = prog.correct||0;
  const w = prog.wrong||0;
  const err = (state.errByKey && state.errByKey[lvl]) ? state.errByKey[lvl] : {};

  // Only archive if there was any activity in the round (otherwise avoid empty rows)
  const hasActivity = mastered>0 || c>0 || w>0 || Object.keys(err).length>0;
  if(!hasActivity) return;

  state.history[lvl].push({
    round: state.rounds[lvl] || 1,
    endedAt: Date.now(),
    mastered,
    correct: c,
    wrong: w,
    errByKey: err
  });

  // keep history bounded (avoid unbounded localStorage growth)
  const MAX = 50;
  if(state.history[lvl].length > MAX){
    state.history[lvl] = state.history[lvl].slice(state.history[lvl].length - MAX);
  }
}
function resetRoundStats(lvl){
  // called when user resets a level (new round)
  ensureRound(lvl);

  // archive current round BEFORE increment & clear
  archiveRoundIfAny(lvl);

  state.rounds[lvl] = (state.rounds[lvl]||1) + 1;
  if(!state.errByKey) state.errByKey = {1:{},2:{},3:{},4:{},5:{},6:{}};
  state.errByKey[lvl] = {};
}
function getRounds(lvl){
  ensureRound(lvl);
  return state.rounds[lvl] || 1;
}
function getHistory(lvl){
  ensureHistory();
  return state.history[lvl] || [];
}
function aggregateErrMap(){
  // combine current + history errors into one map per level
  ensureHistory();
  const out = {1:{},2:{},3:{},4:{},5:{},6:{}};
  for(const lvl of [1,2,3,4,5,6]){
    const add=(m)=>{
      for(const k of Object.keys(m||{})){
        out[lvl][k] = (out[lvl][k]||0) + (m[k]||0);
      }
    };
    // history
    for(const r of (state.history[lvl]||[])){
      add(r.errByKey||{});
    }
    // current round
    add((state.errByKey && state.errByKey[lvl]) ? state.errByKey[lvl] : {});
  }
  return out;
}


function isStarred(lvl, key){
  const map = (state.stars && state.stars[lvl]) ? state.stars[lvl] : {};
  // default: starred (included)
  return map[key] !== false;
}
function setStarred(lvl, key, val){
  if(!state.stars) state.stars = initialState().stars;
  if(!state.stars[lvl]) state.stars[lvl] = {};
  state.stars[lvl][key] = !!val;
}

function countStarredInfs(lvl){
  const all = allInfs();
  let n = 0;
  for(const inf of all){
    if(isStarred(lvl, makeMasterKey(lvl, inf, "inf"))) n++;
  }
  return n;
}

function dominatedStarsStats(lvl){
  // "Dominats" = verbs that are NOT starred (â­ desmarcades) => excluded from practice
  const total = allInfs().length;
  const starred = countStarredInfs(lvl);
  const unstarred = Math.max(0, total - starred);
  return { unstarred, starred, total };
}

function masteredFromStars(lvl){
  // For levels 1/2/4/5/6: â­ means "included in practice" (active).
  // We want mastered/total relative to the active set, not the full 118.
  const all = allInfs();
  const masteredObj = (state.progress && state.progress[lvl] && state.progress[lvl].mastered) ? state.progress[lvl].mastered : {};
  let total = 0;
  let mastered = 0;
  for(const inf of all){
    const key = makeMasterKey(lvl, inf, "inf");
    if(isStarred(lvl, key)){
      total++;
      if(!!masteredObj[inf] || !!masteredObj[key]) mastered++; // support both key styles
    }
  }
  const remaining = Math.max(0, total - mastered);
  return { mastered, total, remaining };
}
function allQuestionKeysForLevel(lvl){
  const keys = [];
  const all = allInfs();
  if(lvl===3){
    const tensesAll = ["inf","past","pp"];
    for(const inf of all){
      for(const t of tensesAll){
        keys.push(makeMasterKey(lvl, inf, t));
      }
    }
    return keys;
  }
  for(const inf of all){
    keys.push(makeMasterKey(lvl, inf, "inf"));
  }
  return keys;
}
function anyStarredInLevel(lvl){
  const keys = allQuestionKeysForLevel(lvl);
  for(const k of keys){
    if(isStarred(lvl, k)) return true;
  }
  return false;
}
function resetAllStarsForLevel(lvl){
  if(!state.stars) state.stars = initialState().stars;
  state.stars[lvl] = {}; // empty means all true by default
}
function ensureStarsNotEmpty(lvl){
  if(!anyStarredInLevel(lvl)){
    resetAllStarsForLevel(lvl);
  }
}
function isFavOnly(lvl){
  return !!(state.favOnly && state.favOnly[lvl]);
}
function setFavOnly(lvl, val){
  if(!state.favOnly) state.favOnly = initialState().favOnly;
  state.favOnly[lvl] = !!val;
}

// FIX22: helper used by updateStatsUI (avoid ReferenceError)
function getFavOnly(lvl){
  return !!(state.favOnly && state.favOnly[lvl]);
}


function openModal(title, bodyHtml, opts={}) {
  const o = Object.assign({ showOk: true, okLabel: UI[getLang()].ok }, opts);
  els.modalTitle.textContent = title;
  els.modalBody.innerHTML = bodyHtml;
  els.modalOk.textContent = o.okLabel;
  els.modalOk.style.display = o.showOk ? "" : "none";
  els.modal.classList.remove("hidden");
  els.modal.classList.add("flex");
}
function closeModal() {
  els.modal.classList.add("hidden");
  els.modal.classList.remove("flex");
}
els.modalClose.addEventListener("click", closeModal);
els.modalOk.addEventListener("click", closeModal);
els.modal.addEventListener("click", (e)=>{ if(e.target === els.modal) closeModal(); });

function shuffle(arr) {
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--) {
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function uniq(arr){ return Array.from(new Set(arr)); }
function pct(n,d){ if(d<=0) return 0; return Math.round((n/d)*100); }
function allInfs(){ return DEFAULT_VERBS.map(v=>v.inf); }
function getVerb(inf){ return DEFAULT_VERBS.find(v=>v.inf===inf); }

function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m]));
}
function getVerbByKey(key){
  const inf = String(key).includes("|") ? String(key).split("|")[0] : String(key);
  return getVerb(inf);
}


function getActiveTenses(){
  if(state.currentLevel!==3) return ["inf"];
  const sel = state.tenseSel || {inf:true,past:false,pp:false};
  const t = [];
  if(sel.inf) t.push("inf");
  if(sel.past) t.push("past");
  if(sel.pp) t.push("pp");
  return t.length ? t : ["inf"];
}

function buildPracticeUniverseForLevel3(tensesOverride, favOnlyOverride){
  const all = allInfs();
  const tenses = Array.isArray(tensesOverride) && tensesOverride.length ? tensesOverride : getActiveTenses();
  ensureStarsNotEmpty(3);
  const favOnly = (typeof favOnlyOverride === "boolean") ? favOnlyOverride : isFavOnly(3);
  const items = [];
  for(const inf of all){
    for(const t of tenses){
      const key = makeMasterKey(3, inf, t);
      if(!favOnly || isStarred(3, key)) items.push(`${inf}|${t}`);
    }
  }
  return items;
}

function tenseLabel(t){
  const u = UI[getLang()];
  if(t==="past") return u.tensePast;
  if(t==="pp") return u.tensePP;
  return u.tenseInf;
}
function makeMasterKey(lvl, inf, tense){
  return (lvl===3) ? `${inf}|${tense}` : inf;
}
function parseQueueItem(lvl, item){
  if(lvl===3){
    const parts = String(item).split("|");
    return { inf: parts[0], tense: parts[1] || "inf" };
  }
  return { inf: String(item), tense: "inf" };
}
function getLevelTotal(lvl){
  if(lvl===3){
    return DEFAULT_VERBS.length * getActiveTenses().length;
  }
  return DEFAULT_VERBS.length;
}
// Total of questions in the current practice pool (respects â­ filter per level and active tenses for L3)
function getPracticeTotal(lvl){
  if(!lvl) return 0;
  ensureStarsNotEmpty(lvl);
  const favOnly = isFavOnly(lvl);
  const all = allInfs();
  if(lvl===3){
    const tenses = getActiveTenses();
    if(!favOnly) return DEFAULT_VERBS.length * tenses.length;
    let c = 0;
    for(const inf of all){
      for(const t of tenses){
        const k = makeMasterKey(lvl, inf, t);
        if(isStarred(lvl, k)) c++;
      }
    }
    return c;
  }
  if(!favOnly) return DEFAULT_VERBS.length;
  let c = 0;
  for(const inf of all){
    const k = makeMasterKey(lvl, inf, "inf");
    if(isStarred(lvl, k)) c++;
  }
  return c;
}
function countMastered(lvl){
  const masteredObj = state.progress[lvl].mastered || {};
  if(lvl!==3) return Object.keys(masteredObj).length;
  const act = new Set(getActiveTenses());
  return Object.keys(masteredObj).filter(k=>{
    const p = k.split("|");
    return p.length===2 && act.has(p[1]);
  }).length;
}


// Round snapshot helpers: a round uses a fixed pool (and fixed filters) until it finishes.
// Changing â­ or "NomÃ©s â­" during a round affects the NEXT round only.
function getRoundSnap(lvl){
  return (state.roundSnap && state.roundSnap[lvl]) ? state.roundSnap[lvl] : null;
}
function roundFavOnly(lvl){
  const s = getRoundSnap(lvl);
  return s ? !!s.favOnly : isFavOnly(lvl);
}
function roundTenses(lvl){
  const s = getRoundSnap(lvl);
  return (s && Array.isArray(s.tenses) && s.tenses.length) ? s.tenses : getActiveTenses();
}
function getRoundTotal(lvl){
  const s = getRoundSnap(lvl);
  return (s && typeof s.total === "number" && s.total > 0) ? s.total : (getPracticeTotal(lvl) || getLevelTotal(lvl));
}

function isLevelUnlocked(lvl){
  return true; // tots els nivells disponibles
}
function updateLevelButtons(){
  els.levelBtns().forEach(btn=>{
    const lvl = parseInt(btn.dataset.level,10);
    btn.classList.remove("btn-disabled");
    btn.classList.toggle("level-active", state.currentLevel===lvl);
    btn.innerHTML = `N${lvl}`;
  });
}
function updateStatsUI(){
  const lvl = state.currentLevel;

  // --- No-level empty state layout ---
  if(!lvl){
    if(els.quizHeaderGrid) els.quizHeaderGrid.classList.add('noLevel');
    if(els.levelHeaderLeft) els.levelHeaderLeft.classList.add('hidden');
    if(els.btnSpeak) els.btnSpeak.classList.add('hidden');
    if(els.quizFooter) els.quizFooter.classList.add('hidden');
    if(els.progressSection) els.progressSection.classList.add('hidden');
  } else {
    if(els.quizHeaderGrid) els.quizHeaderGrid.classList.remove('noLevel');
    if(els.levelHeaderLeft) els.levelHeaderLeft.classList.remove('hidden');
    if(els.btnSpeak) els.btnSpeak.classList.remove('hidden');
    if(els.quizFooter) els.quizFooter.classList.remove('hidden');
    if(els.progressSection) els.progressSection.classList.remove('hidden');
  }

  // qTotal (footer) can respect â­ filter (practice set).
  const practiceTotal = getPracticeTotal(lvl||1) || allInfs().length;

  // Progress:
  // - The progress BAR shows % of correct answers over total questions to be completed in this round.
  //   Total questions = roundTotal + wrong (each error adds one extra repetition).
  // - "Dominats" shows â­ desmarcades / total verbs (independent of "NomÃ©s â­").
  const totalVerbs = allInfs().length;
  const dom = dominatedStarsStats(lvl||1);

  // keep question total in sync (especially for level 3 with tense filters)
  if(lvl && els.qTotal) els.qTotal.textContent = practiceTotal;

  if(!lvl){
    // cap nivell seleccionat encara
    els.progressBar.style.width = `0%`;
    els.progressPct.textContent = `0%`;
    if(els.progressRemain) els.progressRemain.textContent = ``;
    els.scoreLine.textContent = UI[getLang()].correctWrong(0,0);
    els.masterLine.textContent = UI[getLang()].masteredLine(0, totalVerbs);
        if(els.btnReset) els.btnReset.disabled = true;
    updateLevelButtons();
    return;
  }

  const prog = state.progress[lvl] || { mastered:{}, correct:0, wrong:0 };
  const roundTotal = (getPracticeTotal(lvl) || getLevelTotal(lvl));
  const denom = roundTotal + (prog.wrong||0);
  const pctDone = denom>0 ? Math.round(100*(prog.correct||0)/denom) : 0;

  els.progressBar.style.width = `${pctDone}%`;
  const remaining = Math.max(0, denom - (prog.correct||0));

    els.progressPct.textContent = `${pctDone}%`;
  if(els.progressRemain) els.progressRemain.textContent = denom>0 ? `(${(prog.correct||0)}/${denom})` : ``;
  els.scoreLine.textContent = UI[getLang()].correctWrong(prog.correct||0, prog.wrong||0);
  // "Dominats" = â­ desmarcades / total verbs
  els.masterLine.textContent = UI[getLang()].masteredLine(dom.unstarred, dom.total);

  // habilita/deshabilita "Reinicia" nomÃ©s si hi ha progrÃ©s en aquest nivell
  const hasAny = (prog.correct > 0) || (prog.wrong > 0) || (prog.mastered && Object.keys(prog.mastered).length > 0);
  if(els.btnReset) els.btnReset.disabled = !hasAny;
  updateLevelButtons();
}

function setFeedback(html, ok=true){
  els.feedback.innerHTML = html || "";
  els.feedback.className = "text-base font-bold text-center " + (ok ? "text-green-600" : "text-red-600");
}
function clearAnswers(){
  els.answers.innerHTML = "";
  els.level6Area.classList.add("hidden");
  els.level3Letters.classList.add("hidden");
}
function setNextEnabled(enabled){
  els.btnNext.disabled = !enabled;
  if(enabled){
    els.btnNext.classList.remove("bg-blue-300","hover:bg-blue-300");
    els.btnNext.classList.add("bg-blue-500","hover:bg-blue-600");
  } else {
    els.btnNext.classList.add("bg-blue-300","hover:bg-blue-300");
    els.btnNext.classList.remove("bg-blue-500","hover:bg-blue-600");
  }
}
function wiggle(){
  els.quizArea.classList.remove("shake");
  void els.quizArea.offsetWidth;
  els.quizArea.classList.add("shake");
}


/* PronunciaciÃ³ (Web Speech API) */
function canSpeak(){
  return ("speechSynthesis" in window) && ("SpeechSynthesisUtterance" in window);
}

function isAutoAudio(){
  const sel = document.getElementById('audioModeSel');
  if(sel && sel.value) return sel.value === 'auto';
  return (state.audioMode || 'auto') === 'auto';
}
// Speak multiple texts sequentially (skips falsy)
function speakSequence(texts){
  const arr = (texts||[]).map(t=> (t||"").trim()).filter(Boolean);
  if(!arr.length) return;
  // If only one item, use speakEN for maximum compatibility
  if(arr.length===1){ speakEN(arr[0]); return; }

  try{ window.speechSynthesis.cancel(); }catch(e){}

  let i = 0;
  const v = getVoice();
  const lang = (v && v.lang) ? v.lang : 'en-US';

  const speakNext = ()=>{
    if(i>=arr.length) return;
    const u = new SpeechSynthesisUtterance(arr[i++]);
    if(v) u.voice = v;
    u.lang = lang;
    u.rate = 0.95;
    u.onend = ()=> setTimeout(speakNext, 120);
    u.onerror = ()=> setTimeout(speakNext, 120);
    try{ window.speechSynthesis.speak(u); }catch(e){}
  };
  speakNext();
}
function speakEN(text){
  try{
    if(!canSpeak()) return;
    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    // Try to prefer English voice if available
    const voices = window.speechSynthesis.getVoices?.() || [];
    const enVoice = voices.find(v=> (v.lang||"").toLowerCase().startsWith("en"));
    if(enVoice) u.voice = enVoice;
    u.lang = (enVoice && enVoice.lang) ? enVoice.lang : "en-US";
    u.rate = 0.95;
    window.speechSynthesis.speak(u);
  } catch(e){}
}

function getVoice(){
  try{
    const voices = window.speechSynthesis.getVoices?.() || [];
    return voices.find(v=> (v.lang||"").toLowerCase().startsWith("en")) || null;
  }catch(e){
    return null;
  }
}

function hasEnglishVoice(){
  const voices = window.speechSynthesis.getVoices?.() || [];
  return voices.some(v=> (v.lang||"").toLowerCase().startsWith("en"));
}

// FIX35: speak the tense asked in the QUESTION (dynamic at click time to avoid stale handlers)
function speakQuestionTense(){
  try{
    const v = state.current;
    const lvl = state.currentLevel;
    if(!v) return;
    let t = null;
    if(lvl===1) t = v.inf;
    else if(lvl===4) t = v.past;
    else if(lvl===5) t = v.pp;
    if(t) speakEN(t);
  }catch(e){}
}

// FIX49: Speak a sequence without cancelling between items (for N6 auto audio)
function speakQueue(texts){
  const arr = (texts||[]).map(t=>(t||"").trim()).filter(Boolean);
  if(!arr.length) return;
  if(arr.length===1){ speakEN(arr[0]); return; }

  const v = getVoice();
  const lang = (v && v.lang) ? v.lang : 'en-US';

  try{ window.speechSynthesis.cancel(); }catch(e){}

  // Let the browser queue utterances naturally (more reliable than manual chaining in some engines)
  for(const t of arr){
    try{
      const u = new SpeechSynthesisUtterance(t);
      if(v) u.voice = v;
      u.lang = lang;
      u.rate = 0.95;
      window.speechSynthesis.speak(u);
    }catch(e){}
  }
}

// FIX24: small audio button for correct answers
function createInlineAudioBtn(text){
  const s=document.createElement('span');
  s.className='inlineAudio ml-2 inline-flex items-center justify-center rounded px-2 py-1 text-sm bg-slate-200 hover:bg-slate-300 cursor-pointer select-none';
  s.title=(UI[getLang()] && UI[getLang()].pronounceTitle) ? UI[getLang()].pronounceTitle : 'Pronounce';
  s.textContent='ğŸ”Š';
  s.addEventListener('click', (ev)=>{ ev.stopPropagation(); speakEN(text); });
  return s;
}
function updateSpeakButton(v){
  // FIX39: The QUESTION shows the infinitive (N1, N4, N5). It must always pronounce the infinitive.
  // Answers (N4/N5) have their own audio next to the correct option (past / pp).
  const lvl = state.currentLevel;
  if(!els.btnSpeak) return;

  const show = !!(v && v.inf) && canSpeak() && (lvl===1 || lvl===4 || lvl===5);

  els.btnSpeak.classList.toggle("hidden", !show);
  els.btnSpeak.style.display = show ? "" : "none";
  els.btnSpeak.disabled = !show;

  if(show){
    els.btnSpeak.onclick = ()=>{
      try{
        const cur = state.current;
        if(cur && cur.inf) speakEN(cur.inf);
      }catch(e){}
    };
  } else {
    els.btnSpeak.onclick = null;
  }
}
// Some browsers load voices async
if("speechSynthesis" in window){
  window.speechSynthesis.onvoiceschanged = ()=> {
    if(state.current && state.currentLevel===1) updateSpeakButton(state.current);
  // FIX40: auto audio for question
  try{ if(isAutoAudio() && els.btnSpeak && !els.btnSpeak.classList.contains('hidden')) els.btnSpeak.click(); }catch(e){}
  };


  // --- UI helpers: no-level mode + fixed side buttons width ---
  function setNoLevelMode(isNoLevel){
    try{ els.quizArea.classList.toggle("no-level", isNoLevel);}catch(e){}
    if(!els.levelHeaderLeft || !els.quizFooter || !els.progressSection) return;
    try{ els.quizArea.classList.toggle('no-level', isNoLevel);}catch(e){}
    els.levelHeaderLeft.classList.toggle("hidden", isNoLevel);
    els.quizFooter.classList.toggle("hidden", isNoLevel);
    els.progressSection.classList.toggle("hidden", isNoLevel);
    if(els.questionHint) els.questionHint.classList.toggle("hidden", isNoLevel);

    // When no level selected, ensure the main text is the placeholder and disable next
    if(isNoLevel){
      if(els.btnNext) els.btnNext.disabled = true;
      if(els.qCurrent) els.qCurrent.textContent = "â€”";
      if(els.qTotal) els.qTotal.textContent = "â€”";
    }
  }

  function applyFixedSideButtonWidth(){
    try{
      const tmp = document.createElement("span");
      tmp.textContent = "áƒ˜áƒœáƒ¡áƒ¢áƒ áƒ£áƒ¥áƒªáƒ˜áƒ”áƒ‘áƒ˜"; // Georgian longest label
      tmp.style.position = "absolute";
      tmp.style.visibility = "hidden";
      tmp.style.whiteSpace = "nowrap";
      // match button typography roughly
      tmp.style.fontSize = "12px";
      tmp.style.fontWeight = "700";
      tmp.style.fontFamily = getComputedStyle(document.body).fontFamily;
      document.body.appendChild(tmp);
      const w = tmp.getBoundingClientRect().width;
      document.body.removeChild(tmp);
      // add horizontal padding (px-2 = 8px*2) + a little breathing room
      const finalW = Math.ceil(w + 32);
      document.documentElement.style.setProperty("--sideBtnW", finalW + "px");
    }catch(e){}
  }
}

/* similarity helpers */
function levenshtein(a,b){
  a=String(a); b=String(b);
  const m=a.length,n=b.length;
  const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
  for(let i=0;i<=m;i++) dp[i][0]=i;
  for(let j=0;j<=n;j++) dp[0][j]=j;
  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const cost=a[i-1]===b[j-1]?0:1;
      dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
    }
  }
  return dp[m][n];
}

/* Genera variants "creÃ¯bles" (typos) per fer mÃ©s difÃ­cil quan el verb Ã©s igual en tots els temps */
function isVowel(ch){ return "aeiou".includes((ch||"").toLowerCase()); }
function typoVariants(word){
  word = String(word||"").trim();
  if(word.length < 3) return [];
  const vars = new Set();

  // 1) canviar una vocal per una altra (sproad, spreat, etc.)
  const vowels = ["a","e","i","o","u"];
  for(let i=0;i<word.length;i++){
    const ch = word[i].toLowerCase();
    if(isVowel(ch)){
      for(const v of vowels){
        if(v===ch) continue;
        vars.add(word.slice(0,i) + v + word.slice(i+1));
      }
    }
  }

  // 2) intercanviar dues lletres adjacents (raed)
  for(let i=0;i<word.length-1;i++){
    if(word[i] !== word[i+1]){
      vars.add(word.slice(0,i) + word[i+1] + word[i] + word.slice(i+2));
    }
  }

  // 3) afegir/eliminar una lletra comuna al final (spreads, spreadd) - poc, perÃ² Ãºtil
  vars.add(word + "s");
  if(word.length>3) vars.add(word.slice(0,-1));

  // Filtre: nomÃ©s variants amb distÃ ncia petita
  const out = Array.from(vars).filter(v=>{
    const d = levenshtein(word, v);
    return d>=1 && d<=2;
  });

  // Prioritza variants amb canvi de vocal o swap (mÃ©s creÃ¯bles)
  return shuffle(out).slice(0, 10);
}

/* Escull distractors molt semblants; si no n'hi ha prou, crea typos */
function hardDistractors(correct, pool, k){
  const scored = pool
    .filter(x=>x!==correct)
    .map(x=>({x, d: levenshtein(correct, x)}))
    .sort((a,b)=>a.d-b.d);

  const chosen = [];
  for(const o of scored){
    if(o.d <= 2) { // nomÃ©s molt semblants
      if(!chosen.includes(o.x)) chosen.push(o.x);
      if(chosen.length>=k) break;
    }
  }

  if(chosen.length < k){
    const typos = typoVariants(correct);
    for(const t of typos){
      if(chosen.length>=k) break;
      if(t!==correct && !chosen.includes(t)) chosen.push(t);
    }
  }

  // Si encara falten, omple amb les mÃ©s semblants disponibles
  if(chosen.length < k){
    for(const o of scored){
      if(chosen.length>=k) break;
      if(!chosen.includes(o.x) && o.x!==correct) chosen.push(o.x);
    }
  }

  return chosen.slice(0,k);
}
function similarDistractors(correctForm, poolForms, k=2){
  const scored = poolForms
    .filter(x=>x!==correctForm)
    .map(x=>({x, d: levenshtein(correctForm, x)}))
    .sort((a,b)=>a.d-b.d);
  const best = scored.slice(0, 30).map(o=>o.x);
  const chosen=[];
  for(const x of best){
    if(chosen.length>=k) break;
    if(!chosen.includes(x) && x!==correctForm) chosen.push(x);
  }
  if(chosen.length<k){
    const rest = shuffle(poolForms.filter(x=>x!==correctForm && !chosen.includes(x)));
    while(chosen.length<k && rest.length) chosen.push(rest.pop());
  }
  return chosen;
}
function uniquePush(arr, v){
  if(v && !arr.includes(v)) arr.push(v);
}

/* per-verb tricky options */
function makeLevel3Options(v){
  const correct = v.past;
  const opts = [correct];

  // pot sortir infinitiu o participi si sÃ³n diferents
  if(v.inf !== correct) uniquePush(opts, v.inf);
  if(v.pp !== correct) uniquePush(opts, v.pp);

  // distractors difÃ­cils: primer molt semblants (o typos si cal)
  const pool = uniq(DEFAULT_VERBS.map(x=>x.past));
  const need = Math.max(0, 3 - opts.length);
  const extras = hardDistractors(correct, pool, need + 2); // en demanem una mica mÃ©s per variar
  for(const x of extras){
    if(opts.length>=3) break;
    uniquePush(opts, x);
  }

  // assegura 3 opcions
  while(opts.length<3){
    uniquePush(opts, hardDistractors(correct, pool, 1)[0] || pool[Math.floor(Math.random()*pool.length)]);
  }

  return { options: shuffle(opts).slice(0,3), correct, extrasUsed: opts.filter(x=>x!==correct) };
}
function makeLevel4Options(v){
  const correct = v.pp;
  const opts = [correct];

  // pot sortir infinitiu o past simple si sÃ³n diferents
  if(v.inf !== correct) uniquePush(opts, v.inf);
  if(v.past !== correct) uniquePush(opts, v.past);

  const pool = uniq(DEFAULT_VERBS.map(x=>x.pp));
  const need = Math.max(0, 3 - opts.length);
  const extras = hardDistractors(correct, pool, need + 2);
  for(const x of extras){
    if(opts.length>=3) break;
    uniquePush(opts, x);
  }

  while(opts.length<3){
    uniquePush(opts, hardDistractors(correct, pool, 1)[0] || pool[Math.floor(Math.random()*pool.length)]);
  }

  return { options: shuffle(opts).slice(0,3), correct, extrasUsed: opts.filter(x=>x!==correct) };
}
function makeLevel5Pool(v){
  const base = [];
  uniquePush(base, v.inf);
  uniquePush(base, v.past);
  uniquePush(base, v.pp);

  const l3 = makeLevel3Options(v).extrasUsed;
  const l4 = makeLevel4Options(v).extrasUsed;
  const tricky = shuffle(uniq(l3.concat(l4))).filter(x=>!base.includes(x));

  for(const x of tricky){
    if(base.length>=5) break;
    uniquePush(base, x);
  }
  const pool = uniq(DEFAULT_VERBS.map(x=>x.past).concat(DEFAULT_VERBS.map(x=>x.pp)).concat(allInfs()));
  const extra = shuffle(pool).filter(x=>!base.includes(x));
  while(base.length<5 && extra.length){
    uniquePush(base, extra.pop());
  }
  return base.slice(0,5);
}

/* Wrong answers return at end (shuffled) */
function addRetry(item){
  const lvl = state.currentLevel;
  // If "only â­" is active, never retry items that are not starred anymore.
  if(isFavOnly(lvl)){
    if(lvl===3){
      const parsed = parseQueueItem(lvl, item);
      const qKey = makeMasterKey(lvl, parsed.inf, parsed.tense);
      if(!isStarred(lvl, qKey)) return;
    } else {
      const inf = String(item);
      const qKey = makeMasterKey(lvl, inf, "inf");
      if(!isStarred(lvl, qKey)) return;
    }
  }
  const list = state.retries[lvl] || [];
  if(!list.includes(item)) list.push(item);
  state.retries[lvl] = list;
}

function renderMCQ(options, correct, onCorrect){
  // FIX34: Keep original option button design (optBtn) for N1,
  // and for N2/N4/N5 show an adjacent audio button (not nested) that activates only for the correct option after answering.
  els.level6Area.classList.add("hidden");
  els.level3Letters.classList.add("hidden");
  els.answers.innerHTML = "";

  // always shuffle options positions
  options = shuffle(options);

  const lvl = state.currentLevel;
  const audioOnOptions = (lvl===2 || lvl===4 || lvl===5);

  // reset answered flag per question
  state.answered = false;

  const rows = [];

  function makeAudioIcon(word){
    const a = document.createElement("button");
    a.type = "button";
    a.className = "optAudio iconBtn";
    a.textContent = "ğŸ”Š";
    a.title = (UI[getLang()] && UI[getLang()].pronounceTitle) ? UI[getLang()].pronounceTitle : "Pronounce";
    a.disabled = true;
    a.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      if(a.disabled) return;
      speakEN(word);
    });
    return a;
  }

  function enableAudioForCorrect(){
    if(!audioOnOptions) return;
    rows.forEach(r=>{
      const isCorrect = (r.opt === correct);
      r.audioBtn.disabled = !isCorrect;
      r.audioBtn.classList.toggle("optAudioOn", isCorrect);
    });
  }

  options.forEach((opt)=>{
    // original button design
    const btn=document.createElement("button");
    btn.className="optBtn bg-white border border-slate-200 rounded-xl px-4 py-3 text-left";
    btn.textContent = opt;

    let audioBtn = null;
    if(audioOnOptions){
      const row = document.createElement("div");
      row.className = "optRow";
      audioBtn = makeAudioIcon(opt);
      row.appendChild(btn);
      row.appendChild(audioBtn);
      els.answers.appendChild(row);
      rows.push({btn, audioBtn, opt});
    } else {
      els.answers.appendChild(btn);
    }

    btn.addEventListener("click", ()=>{
      if(state.answered) return;
      state.answered = true;

      const buttons = Array.from(els.answers.querySelectorAll("button.optBtn"));
      buttons.forEach(b=>{
        b.disabled = true;
        b.classList.add("optLocked");
      });

      const ok = (opt === correct);
      if(ok){
        btn.classList.add("optCorrect");
        setFeedback(UI[getLang()].good, true);
        state.progress[state.currentLevel].correct += 1;
        onCorrect?.();
      } else {
        btn.classList.add("optWrong");
        const correctBtn = buttons.find(b=>b.textContent===correct);
        if(correctBtn) correctBtn.classList.add("optReveal");
        setFeedback(UI[getLang()].notCorrect, false);
        state.progress[state.currentLevel].wrong += 1;
        noteWrong(state.currentLevel, state.currentKey || state.current.inf);
        addRetry(state.currentKey || state.current.inf);
        wiggle();
      }

      // enable audio only for correct option after answering
      try{ if(canSpeak()) enableAudioForCorrect(); }catch(e){}
      // FIX40: auto audio for correct answer (MCQ levels)
      try{ if(isAutoAudio() && audioOnOptions && canSpeak()) speakEN(correct); }catch(e){}

      saveState();
      updateStatsUI();
      setNextEnabled(true);
    });
  });

  setNextEnabled(false);
}

function maybeFinishLevel(){
  const lvl = state.currentLevel;
  if(countMastered(lvl) >= DEFAULT_VERBS.length){
    if(lvl < 6){
      openModal(
        UI[getLang()].lvlCompleted(lvl),
        UI[getLang()].lvlCompletedBody(lvl),
        { showOk: false }
      );
      setTimeout(()=>{
        const r=document.getElementById("btnResetAfterComplete");
        if(r) r.onclick = ()=>{
          // Reinicia NOMÃ‰S aquest nivell i torna a comenÃ§ar
          resetRoundStats(lvl);
          state.progress[lvl] = { mastered: {}, correct: 0, wrong: 0 };
          state.retries[lvl] = [];
          state.queue = [];
          state.current = null;
          state.answered = false;
          saveState();
          closeModal();
          startLevel(lvl);
          updateStatsUI();
        };

        const n=document.getElementById("btnNextLevel");
        if(n) n.onclick = ()=>{
          closeModal();
          startLevel(lvl+1);
        };
      },0);
    } else {
      openModal(UI[getLang()].gameDoneTitle, UI[getLang()].gameDoneBody);
    }
  }
}

function buildQueueForLevel(lvl){
  const all = allInfs();
  const masteredSet = state.progress[lvl].mastered || {};
  // Ensure stars not empty (auto reset if needed)
  ensureStarsNotEmpty(lvl);
  const favOnly = isFavOnly(lvl);

  if(lvl===3){
    const tenses = getActiveTenses(); // only active tenses used for practice pool
    const allItems = [];
    for(const inf of all){
      for(const t of tenses){
        const qKey = makeMasterKey(lvl, inf, t);
        if(!favOnly || isStarred(lvl, qKey)){
          allItems.push(`${inf}|${t}`);
        }
      }
    }
    // If favOnly removed everything (e.g. stars empty for active tenses), fall back to all active items
    const safeAll = allItems.length ? allItems : (()=> {
      const fallback = [];
      for(const inf of all){
        for(const t of tenses){
          fallback.push(`${inf}|${t}`);
        }
      }
      return fallback;
    })();

    const notMastered = safeAll.filter(k=>!masteredSet[k]);
    const mastered = safeAll.filter(k=>!!masteredSet[k]);
    const pool = shuffle(notMastered.concat(shuffle(mastered)));
    return pool.length ? pool : shuffle(safeAll);
  }

  const safeAll = favOnly ? all.filter(inf=>isStarred(lvl, makeMasterKey(lvl, inf, "inf"))) : all;
  const notMastered = safeAll.filter(inf=>!masteredSet[inf]);
  const mastered = safeAll.filter(inf=>!!masteredSet[inf]);
  const pool = shuffle(notMastered.concat(shuffle(mastered)));
  return pool.length ? pool : shuffle(safeAll.length ? safeAll : all);
}

function buildNotMasteredQueueForLevel(lvl){
  const all = allInfs();
  const masteredSet = state.progress[lvl].mastered || {};
  ensureStarsNotEmpty(lvl);
  const favOnly = isFavOnly(lvl);

  if(lvl===3){
    const tenses = getActiveTenses();
    const safeAll = [];
    for(const inf of all){
      for(const t of tenses){
        const qKey = makeMasterKey(lvl, inf, t);
        if(!favOnly || isStarred(lvl, qKey)){
          safeAll.push(`${inf}|${t}`);
        }
      }
    }
    const notMastered = safeAll.filter(k=>!masteredSet[k]);
    return shuffle(notMastered);
  }

  const safeAll = favOnly ? all.filter(inf=>isStarred(lvl, makeMasterKey(lvl, inf, "inf"))) : all;
  const notMastered = safeAll.filter(inf=>!masteredSet[inf]);
  return shuffle(notMastered);
}

function prunePoolsForLevel(lvl){
  const favOnly = isFavOnly(lvl);
  if(!favOnly) return;
  const keep = (item)=>{
    if(!item) return false;
    if(lvl===3){
      const parsed = parseQueueItem(lvl, item);
      const qKey = makeMasterKey(lvl, parsed.inf, parsed.tense);
      return isStarred(lvl, qKey);
    } else {
      const inf = String(item);
      const qKey = makeMasterKey(lvl, inf, "inf");
      return isStarred(lvl, qKey);
    }
  };
  state.queue = (state.queue || []).filter(keep);
  const r = state.retries[lvl] || [];
  state.retries[lvl] = r.filter(keep);
}

function showRoundFinishedModal(lvl){
  const lang = getLang();
  const titles = { ca:"Partida acabada!", es:"Â¡Partida terminada!", en:"Round completed!" , ka:"Round completed!" };
  const body1 = { ca:"Has completat tots els verbs seleccionats per aquesta ronda.",
                  es:"Has completado todos los verbos seleccionados de esta ronda.",
                  en:"You completed all selected verbs for this round.",
                  ka:"You completed all selected verbs for this round." };
  const body2 = { ca:"Pots reiniciar per comenÃ§ar una nova ronda o canviar filtres (â­ / temps).",
                  es:"Puedes reiniciar para empezar una nueva ronda o cambiar filtros (â­ / tiempos).",
                  en:"You can reset to start a new round or change filters (â­ / tenses).",
                  ka:"You can reset to start a new round or change filters (â­ / tenses)." };
  openModal(titles[lang] || titles.en, `<p>${body1[lang]||body1.en}</p><p class="mt-2 text-sm opacity-80">${body2[lang]||body2.en}</p>`);
}



function takeNextItem(){
  const lvl = state.currentLevel;
  if(state.queue.length) return state.queue.shift();

  const r = state.retries[lvl] || [];
  if(r.length){
    state.queue = shuffle(r);
    state.retries[lvl] = [];
    saveState();
    return state.queue.shift();
  }

  // Round finished: no more queued items and no retries.
  return null;
}

function nextQuestion(){
  const lvl = state.currentLevel;
  const item = takeNextItem();
  if(!item){
    showRoundFinishedModal(lvl);
    return;
  }
  const parsed = parseQueueItem(lvl, item);
  const inf = parsed.inf;
  const tense = parsed.tense;
  const v = getVerb(inf);

  state.current = v;
  state.currentTense = (lvl===3)? tense : 'inf';
  state.currentKey = makeMasterKey(lvl, inf, (lvl===3)?tense:'inf');
  state.answered = false;

  updateSpeakButton(v);
  syncStarUI();
  syncStudyControlsUI();

  clearAnswers();
  setFeedback("");
  setNextEnabled(false);

  els.levelTitle.textContent = UI[getLang()].level(lvl);
  const totalForLvl = getRoundTotal(lvl);
  els.qTotal.textContent = totalForLvl;

  // Show progress as "mastered so far + 1" (never exceeds total), instead of raw attempts
  const prog = state.progress[lvl] || { mastered:{} };
  let masteredNow = 0;
  if(lvl===3){
    const active = buildPracticeUniverseForLevel3(roundTenses(3), roundFavOnly(3));
    const ms = prog.mastered || {};
    masteredNow = active.filter(k=>!!ms[k]).length;
  } else {
    const ms = prog.mastered || {};
    const favOn = roundFavOnly(lvl);
    const all = allInfs();
    const activeInfs = favOn ? all.filter(inf=>isStarred(lvl, makeMasterKey(lvl, inf, "inf"))) : all;
    masteredNow = activeInfs.filter(inf=>!!ms[inf]).length;
  }
  els.qIndex.textContent = String(Math.min(totalForLvl, masteredNow + 1));

  if(lvl===1) return buildLevel1(v);
  if(lvl===2) return buildLevel2(v);
  if(lvl===3) return buildLevel3(v);
  if(lvl===4) return buildLevel4(v);
  if(lvl===5) return buildLevel5(v);
  if(lvl===6) return buildLevel6(v);
}

function buildLevel1(v){
  els.questionText.textContent = v.inf;
  els.questionHint.textContent = UI[getLang()].hintL1;
  
  normalizeQuestionText();const pool = DEFAULT_VERBS.map(x=>meaningForLang(x));
  const correct = meaningForLang(v);
  const options = [correct, ...shuffle(pool.filter(x=>x!==correct)).slice(0,2)];
  renderMCQ(options, correct, ()=>{ state.progress[1].mastered[v.inf]=true; saveState(); updateStatsUI(); });
}
function buildLevel2(v){
  els.questionText.textContent = meaningForLang(v);
  els.questionHint.textContent = UI[getLang()].hintL2;
  
  normalizeQuestionText();const pool = allInfs();
  const correct = v.inf;
  const options = [correct, ...shuffle(pool.filter(x=>x!==correct)).slice(0,2)];
  renderMCQ(options, correct, ()=>{ state.progress[2].mastered[v.inf]=true; saveState(); updateStatsUI(); });
}
function buildLevel3(v){
  // Verb en catalÃ  -> completa el verb en anglÃ¨s amb lletres
  const t = state.currentTense || "inf";
  // Question text: show meaning + small tense label
  const qBase = (meaningForLang(v) || v.inf);
  els.questionText.innerHTML = "";
  els.questionText.appendChild(document.createTextNode(qBase + " "));
  const tSpan = document.createElement("span");
  tSpan.className = "tenseSmall";
  tSpan.textContent = "(" + tenseLabel(t) + ")";
  els.questionText.appendChild(tSpan);
  els.questionHint.textContent = UI[getLang()].hintL3;

  
  normalizeQuestionText();
  els.level3Letters.classList.remove("hidden");
  els.level6Area.classList.add("hidden");
  els.answers.innerHTML = "";

  const tForm = (t==="past") ? (v.past || v.past_raw || v.inf) : (t==="pp") ? (v.pp || v.pp_raw || v.inf) : (v.inf || "");
  const target = String(tForm).split("/")[0].trim().toLowerCase();
  const letters = target.split("");
  // Track whether user made any mistake in this word
  state.l3HadMistake = false;
  // Help (hint) & audio buttons
  const baseLen = letters.filter(ch=>ch !== "-").length;
  let maxHints;
  if(baseLen <= 3) maxHints = 1;
  else if(baseLen <= 5) maxHints = 2;
  else if(baseLen <= 7) maxHints = 3;
  else maxHints = Math.max(3, Math.floor((2 * baseLen) / 3));
  maxHints = Math.max(1, Math.min(baseLen - 1, maxHints));
  state.l3HintsUsed = 0;
  if(els.btnL3Audio){
    els.btnL3Audio.disabled = true;
    els.btnL3Audio.onclick = ()=> speakEN(target);
  }
  if(els.btnL3Help){
    els.btnL3Help.disabled = (maxHints <= 0);
    els.btnL3Help.onclick = ()=> {
      if(maxHints <= 0) return;
      if(state.l3HintsUsed >= maxHints) { els.btnL3Help.disabled = true; return; }
      // Pick a random empty slot (non-hyphen)
      const empties = [];
      for(let i=0;i<letters.length;i++){
        if(letters[i]==="-") continue;
        if(slotEls[i].textContent==="") empties.push(i);
      }
      if(!empties.length){ els.btnL3Help.disabled = true; return; }
      const pick = empties[Math.floor(Math.random()*empties.length)];
      const correctCh = letters[pick];
      slotEls[pick].textContent = correctCh.toUpperCase();
      state.l3HintsUsed += 1;
      if(state.l3HintsUsed >= maxHints) els.btnL3Help.disabled = true;

      // Disable one matching letter button from the bank (if any remains enabled)
      const btns = Array.from(els.letterBank.querySelectorAll("button"));
      const matchBtn = btns.find(b=> !b.disabled && (b.textContent||"").toLowerCase()===correctCh);
      if(matchBtn){ matchBtn.disabled = true; matchBtn.style.opacity = "0.4"; }

      // If now complete, finish word
      const remaining = slotEls.some((s,i)=> letters[i] !== "-" && s.textContent==="");
      if(!remaining){
        complete();
      }
    };
  }

  els.letterSlots.innerHTML = "";
  els.letterBank.innerHTML = "";

  let idx = 0;
  const slotEls = [];

  // crea slots
  letters.forEach(ch=>{
    const slot = document.createElement("div");
    slot.className = "w-9 h-10 rounded-lg border bg-slate-50 flex items-center justify-center text-lg font-bold";
    slot.textContent = (ch === "-") ? "-" : "";
    slotEls.push(slot);
    els.letterSlots.appendChild(slot);
  });

  // pool de lletres: lletres del verb + extres
  const alphabet = "abcdefghijklmnopqrstuvwxyz";
  const base = letters.filter(ch=>ch !== "-");
  const extraCount = Math.max(6, Math.min(12, base.length));
  const extras = Array.from({length: extraCount}, ()=> alphabet[Math.floor(Math.random()*alphabet.length)]);
  const pool = shuffle(base.concat(extras));

  function advanceHyphens(){
    while(idx < letters.length && letters[idx] === "-"){
      slotEls[idx].textContent = "-";
      idx++;
    }
  }
  function complete(){
    const key = state.currentKey || makeMasterKey(3, v.inf, state.currentTense || "inf");
    if(!state.progress[3].mastered[key]){
      // Count per WORD (not per letter): correct only if no mistakes
      if(state.l3HadMistake){
        state.progress[3].wrong += 1;
        noteWrong(3, state.currentKey || (state.current && state.current.inf ? makeMasterKey(3, state.current.inf, state.current.tense||'inf') : null));
        setFeedback(UI[getLang()].bad, true);
      } else {
        state.progress[3].correct += 1;
        setFeedback(UI[getLang()].good, true);
      }
      state.progress[3].mastered[key] = true;
    } else {
      // Already mastered: just show feedback
      setFeedback(state.l3HadMistake ? UI[getLang()].bad : UI[getLang()].good, true);
    }
    // Enable audio once completed, disable help
    if(els.btnL3Audio) els.btnL3Audio.disabled = false;
    if(els.btnL3Help) els.btnL3Help.disabled = true;

    saveState(); updateStatsUI();
    setNextEnabled(true);
    // Auto audio: speak the target word (tense in question) when completed
    try{ if(isAutoAudio()) speakEN(target); }catch(e){}
    maybeFinishLevel();
  }

  advanceHyphens();

  pool.forEach(ch=>{
    const b = document.createElement("button");
    b.className = "relative bg-slate-200 hover:bg-slate-300 rounded-lg px-2 py-2 font-bold text-base min-w-[40px]";
    b.textContent = ch.toUpperCase();

    b.addEventListener("click", ()=>{
      // troba el segÃ¼ent slot buit que correspongui a aquesta lletra
      const chLower = ch;

      // llista d'Ã­ndexs buits
      const emptyIdx = [];
      for(let i=0;i<letters.length;i++){
        if(letters[i]==="-") continue;
        if(slotEls[i].textContent==="") emptyIdx.push(i);
      }
      if(emptyIdx.length===0) return;

      // primer Ã­ndex buit que coincideixi amb la lletra clicada
      const match = emptyIdx.find(i=>letters[i]===chLower);

      if(match !== undefined){
        slotEls[match].textContent = chLower.toUpperCase();
        b.remove();

        // completat?
        const remaining = slotEls.some((s,i)=> letters[i] !== "-" && s.textContent==="");
        if(!remaining){
          complete();
        }
      } else {
        // incorrecte: mark mistake (but don't count per-letter)
        state.l3HadMistake = true;
        // X vermella centrada
        const existing = b.querySelector("span");
        if(existing) existing.remove();
        const x = document.createElement("span");
        x.textContent = "âœ–";
        x.style.position="absolute";x.style.inset="0";x.style.display="flex";x.style.alignItems="center";x.style.justifyContent="center";x.style.color="#dc2626";x.style.fontSize="1.6rem";x.style.fontWeight="900";x.style.pointerEvents="none";
        b.appendChild(x);

        state.l3HadMistake = true;
      
        b.classList.add("shake");
        setTimeout(()=>b.classList.remove("shake"), 300);
}
    });

    els.letterBank.appendChild(b);
  });

  setFeedback("", true);
      try{ syncN6Audio(); }catch(e){}
  setNextEnabled(false);
  updateStatsUI();
}

function buildLevel4(v){
  // Show main verb + meaning in smaller parentheses
  const paren = (meaningForLang(v) || v.ca || "").trim();
  els.questionText.innerHTML = "";
  els.questionText.appendChild(document.createTextNode(v.inf));
  if(paren){
    els.questionText.appendChild(document.createTextNode(" "));
    const s = document.createElement("span");
    s.className = "tenseSmall";
    s.textContent = "(" + paren + ")";
    els.questionText.appendChild(s);
  }
  els.questionHint.textContent = UI[getLang()].hintL4;
  
  normalizeQuestionText();const { options, correct } = makeLevel3Options(v);
  renderMCQ(options, correct, ()=>{ state.progress[3].mastered[v.inf]=true; saveState(); updateStatsUI(); });
}

function buildLevel5(v){
  // Show main verb + meaning in smaller parentheses
  const paren = (meaningForLang(v) || v.ca || "").trim();
  els.questionText.innerHTML = "";
  els.questionText.appendChild(document.createTextNode(v.inf));
  if(paren){
    els.questionText.appendChild(document.createTextNode(" "));
    const s = document.createElement("span");
    s.className = "tenseSmall";
    s.textContent = "(" + paren + ")";
    els.questionText.appendChild(s);
  }
  els.questionHint.textContent = UI[getLang()].hintL5;
  
  normalizeQuestionText();const { options, correct } = makeLevel4Options(v);
  renderMCQ(options, correct, ()=>{ state.progress[4].mastered[v.inf]=true; saveState(); updateStatsUI(); });
}

function buildLevel6(v){
  // Reset auto-audio state for level 6 on each new question
  state.n6LastOk = {inf:false, past:false, pp:false};
  // New question: allow checking again
  state.answered = false;
  if(els.btnCheckLevel6) els.btnCheckLevel6.disabled = false;
  els.questionText.textContent = meaningForLang(v) || v.inf;
  els.questionHint.innerHTML = UI[getLang()].hintL6;
  els.level6Area.classList.remove("hidden");

  const pool = makeLevel5Pool(v); // 5 options (mateixes als 3 selectors)

  fillSelect(els.selInf, shuffle(pool));
  fillSelect(els.selPast, shuffle(pool));
  fillSelect(els.selPP, shuffle(pool));

  els.selInf.value=""; els.selPast.value=""; els.selPP.value=""; 

  // FIX25: N6 audio buttons pronounce selected value (each tense)
  function syncN6Audio(){
    if(els.btnSpeakInf) els.btnSpeakInf.disabled = !els.selInf.value;
    if(els.btnSpeakPast) els.btnSpeakPast.disabled = !els.selPast.value;
    if(els.btnSpeakPP) els.btnSpeakPP.disabled = !els.selPP.value;
  }
  if(els.btnSpeakInf) els.btnSpeakInf.onclick = ()=>{ if(els.selInf.value) speakEN(els.selInf.value); };
  if(els.btnSpeakPast) els.btnSpeakPast.onclick = ()=>{ if(els.selPast.value) speakEN(els.selPast.value); };
  if(els.btnSpeakPP) els.btnSpeakPP.onclick = ()=>{ if(els.selPP.value) speakEN(els.selPP.value); };
  syncN6Audio();

// Next sempre desactivat fins encertar
  setNextEnabled(false);

  // helpers visuals
  const wrapInf = els.selInf.closest("#level6Area .grid > div");
  const wrapPast = els.selPast.closest("#level6Area .grid > div");
  const wrapPP = els.selPP.closest("#level6Area .grid > div");
  // Reset colors for new question
  if(wrapInf) wrapInf.className = "bg-white rounded-lg p-2 border";
  if(wrapPast) wrapPast.className = "bg-white rounded-lg p-2 border";
  if(wrapPP) wrapPP.className = "bg-white rounded-lg p-2 border";

  // FIX54: reset last-ok transitions per question
  state.n6LastOk = { inf:false, past:false, pp:false };

  function clearWrap(w){
    if(!w) return;
    w.classList.remove("bg-green-100","border-green-500","bg-red-100","border-red-500");
    w.classList.add("bg-white");
  }
  function setWrap(w, ok){
    if(!w) return;
    w.classList.remove("bg-white","bg-green-100","border-green-500","bg-red-100","border-red-500");
    if(ok===null){
      w.classList.add("bg-white");
    } else if(ok){
      w.classList.add("bg-green-100","border-green-500");
    } else {
      w.classList.add("bg-red-100","border-red-500");
    }
  }

  // FIX51: reset wraps at start of each new question
  setWrap(wrapInf, null); setWrap(wrapPast, null); setWrap(wrapPP, null);

  // reset visuals when user changes a selector
  [els.selInf, els.selPast, els.selPP].forEach(sel=>{
    sel.addEventListener("change", ()=>{
      // nomÃ©s netegem el seu wrap (per no perdre feedback dels altres)
      if(sel===els.selInf) setWrap(wrapInf, null);
      if(sel===els.selPast) setWrap(wrapPast, null);
      if(sel===els.selPP) setWrap(wrapPP, null);
      setFeedback("", true);
      try{ syncN6Audio(); }catch(e){}
    }, { once:false });
  });


  els.btnCheckLevel6.onclick = ()=>{
    if(state.answered){ return; }
    const a=els.selInf.value, b=els.selPast.value, c=els.selPP.value;

    const hasInf = !!a, hasPast = !!b, hasPP = !!c;
    const okInf = hasInf && (a===v.inf);
    const okPast = hasPast && (b===v.past);
    const okPP = hasPP && (c===v.pp);

    if(!hasInf || !hasPast || !hasPP){
      setFeedback(UI[getLang()].needAllSelects, false);
      wiggle();
      return;
    }

    setWrap(wrapInf, okInf);
    setWrap(wrapPast, okPast);
    setWrap(wrapPP, okPP);

    const allOk = okInf && okPast && okPP;

    // N6 Audio: siempre pronunciar TODOS los verbos correctos al hacer clic en "Comprovar"
    try{
      if(isAutoAudio()){
        const toSpeak = [];
        if(okInf) toSpeak.push(v.inf);
        if(okPast) toSpeak.push(v.past);
        if(okPP) toSpeak.push(v.pp);
        if(toSpeak.length > 0){
          speakQueue(toSpeak);
        }
      }
    }catch(e){}

    if(allOk){
      // ara sÃ­: marquem com complet i deixem avanÃ§ar
      state.answered = true;
      if(els.btnCheckLevel6) els.btnCheckLevel6.disabled = true;
      state.progress[6].correct += 1;
      state.progress[6].mastered[v.inf]=true;

      setFeedback(UI[getLang()].lvl6Good, true);
      saveState(); updateStatsUI();
      setNextEnabled(true);
      maybeFinishLevel();
    } else {
      // permet reintentar tantes vegades com calgui
      state.answered = false;
      state.progress[6].wrong += 1;
      noteWrong(6, state.currentKey || (state.current && state.current.inf));
      setFeedback(UI[getLang()].stillNot, false);
      saveState(); updateStatsUI();
      setNextEnabled(false);
      wiggle();
    }
  };

  updateStatsUI();
}


function escHtml(s){
  return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
}
function fillSelect(sel, options){
  sel.innerHTML = `<option value="">â€” selecciona â€”</option>` +
    options.map(o=>`<option value="${escHtml(o)}">${escHtml(o)}</option>`).join("");
}




function startLevel(lvl){
  if(!isLevelUnlocked(lvl)){
    setFeedback(UI[getLang()].lockedLevel, false);
    return;
  }

  // Si ja estem dins aquest nivell i ja hi ha una pregunta, NO reiniciem ni canviem pregunta
  if(state.currentLevel===lvl && state.current){
    updateStatsUI(); // nomÃ©s per assegurar highlight
    return;
  }

  state.currentLevel = lvl;
  applyLevelMode();
  setNoLevelMode(false);
  try{ syncTenseFiltersUI();
  syncStudyControlsUI();
  syncStarUI(); }catch(e){}
  state.queue = buildQueueForLevel(lvl);
  state.roundSnap = state.roundSnap || {};
  state.roundSnap[lvl] = { favOnly: isFavOnly(lvl), tenses: (lvl===3 ? getActiveTenses().slice() : null), total: state.queue.length };
  state.qPos[lvl] = 0;
  state.levelCompleteShown[lvl] = false;
  state.retries[lvl] = [];
  state.current = null;
  state.answered = false;

  saveState(); updateStatsUI();
  nextQuestion();
  updateSpeakButton(state.current);
  // FIX40: auto audio for question
  try{ if(isAutoAudio() && els.btnSpeak && !els.btnSpeak.classList.contains('hidden')) els.btnSpeak.click(); }catch(e){}
}


// Language selector
(function initLang(){
  const sel = document.getElementById("langSel");
  if(sel){
    sel.value = getLang();
    sel.addEventListener("change", ()=>{
      setLang(sel.value);
      applyLanguage();
    });
  }
})();
els.levelBar.addEventListener("click", (e)=>{
  const btn = e.target.closest("button[data-level]");
  if(!btn) return;
  startLevel(parseInt(btn.dataset.level,10));
});
els.btnNext.addEventListener("click", ()=>{
  if(els.btnNext.disabled) return;
  nextQuestion();
  updateSpeakButton(state.current);
  // FIX40: auto audio for question
  try{ if(isAutoAudio() && els.btnSpeak && !els.btnSpeak.classList.contains('hidden')) els.btnSpeak.click(); }catch(e){}
});


function openVerbList(){
  // Build table rows (same logic as before)
  const rowsHtml = DEFAULT_VERBS.map(v=>{
    const inf = (v.inf||"").trim();
    const past = (v.past||"").trim();
    const pp = (v.pp||"").trim();

    const ca = (getLang && typeof getLang==="function")
      ? (v[getLang()] ?? v.ca ?? v.es ?? v.en ?? "")
      : (v.ca ?? v.es ?? v.en ?? "");

    const eqAll = (inf===past && past===pp);
    const eqInfPast = (inf===past && past!==pp);
    const eqInfPP = (inf===pp && inf!==past);
    const eqPastPP = (past===pp && past!==inf);

    const diff = (eqAll ? "easy" : (eqInfPast||eqInfPP||eqPastPP) ? "mid" : "hard");

    function cellClass(kind){
      if(eqAll) return "bg-emerald-100";
      if(eqInfPast){
        if(kind==="inf"||kind==="past") return "bg-yellow-100";
        return "bg-yellow-50";
      }
      if(eqInfPP){
        if(kind==="inf"||kind==="pp") return "bg-yellow-100";
        return "bg-yellow-50";
      }
      if(eqPastPP){
        if(kind==="past"||kind==="pp") return "bg-yellow-100";
        return "bg-yellow-50";
      }
      return "bg-orange-200";
    }

    // Store a normalized search string in a data attr (built later) via JS
    return `<tr class="border-b" data-diff="${diff}">
      <td class="px-3 py-2 font-mono ${cellClass("inf")}">${inf}</td>
      <td class="px-3 py-2 font-mono ${cellClass("past")}">${past}</td>
      <td class="px-3 py-2 font-mono ${cellClass("pp")}">${pp}</td>
      <td class="px-3 py-2">${ca}</td>
    </tr>`;
  }).join("");

  const overlay = document.getElementById("verbListModal");
  const tbody = document.getElementById("verbListTbody");
  const titleEl = document.getElementById("verbListTitle");
  const colorsLabelEl = document.getElementById("verbListColorsLabel");
  const closeBtnEl = document.getElementById("verbListCloseBtn");
  const closeXEl = document.getElementById("verbListCloseX");
  const countEl = document.getElementById("verbListCount");
  const qEl0 = document.getElementById("verbListSearch");

  if(!overlay || !tbody || !qEl0 || !countEl){
    openModal("Error", "<p>No s'ha pogut obrir la llista de verbs (falten elements del modal).</p>");
    return;
  }

  // Apply translations (keep behavior consistent with current language)
  const L = (window.UI && typeof getLang==="function" && UI[getLang()]) ? UI[getLang()] : null;

  if(titleEl) titleEl.textContent = (L && L.verbListTitle) ? L.verbListTitle : "Llista de verbs";
  if(colorsLabelEl) colorsLabelEl.textContent = (L && L.colors && L.colors.label) ? L.colors.label : "Colors:";

  const colorBtns0 = Array.from(overlay.querySelectorAll(".verbColorBtn"));
  colorBtns0.forEach(btn=>{
    const f = btn.dataset.filter;
    if(!L || !L.colors) return;
    if(f==="easy" && L.colors.easy) btn.textContent = L.colors.easy;
    if(f==="mid" && L.colors.mid) btn.textContent = L.colors.mid;
    if(f==="hard" && L.colors.hard) btn.textContent = L.colors.hard;
  });

  if(closeBtnEl) closeBtnEl.textContent = (L && L.close) ? L.close : "Tancar";

  // Table headers (if available in UI)
  const thInf = document.getElementById("verbListThInf");
  const thPast = document.getElementById("verbListThPast");
  const thPP = document.getElementById("verbListThPP");
  const thTr = document.getElementById("verbListThTr");
  if(L && L.table){
    if(thInf && L.table.inf) thInf.textContent = L.table.inf;
    if(thPast && L.table.past) thPast.textContent = L.table.past;
    if(thPP && L.table.pp) thPP.textContent = L.table.pp;
    if(thTr && (L.table.tr || L.table.translation)) thTr.textContent = (L.table.tr || L.table.translation);
  }

  qEl0.placeholder = (L && L.searchPh) ? L.searchPh : "Cerca...";

  // Fill table
  tbody.innerHTML = rowsHtml;

  // Precompute normalized text for searching
  const norm = (s)=> (s||"").toString().trim().toLowerCase()
    .normalize("NFD").replace(/\p{Diacritic}/gu,"");

  const trs = Array.from(tbody.querySelectorAll("tr"));
  trs.forEach(tr=>{
    tr.dataset.search = norm(tr.textContent);
  });

  // Reset filters
  let term = "";
  const selected = new Set(); // empty => all (same UX as before)

  function applyFilters(){
    let shown = 0;
    trs.forEach(tr=>{
      const d = tr.dataset.diff;
      const okDiff = (selected.size===0) ? true : selected.has(d);
      const okTerm = (term==="") ? true : (tr.dataset.search || "").includes(term);
      const ok = okDiff && okTerm;
      tr.classList.toggle("hidden", !ok);
      if(ok) shown++;
    });
    countEl.textContent = String(shown);
  }

  // To avoid accumulating listeners, clone the interactive elements (cheap + safe)
  const qEl = qEl0.cloneNode(true);
  qEl0.parentNode.replaceChild(qEl, qEl0);

  const closeBtn = closeBtnEl ? closeBtnEl.cloneNode(true) : null;
  if(closeBtnEl && closeBtn){
    closeBtnEl.parentNode.replaceChild(closeBtn, closeBtnEl);
  }
  const closeX = closeXEl ? closeXEl.cloneNode(true) : null;
  if(closeXEl && closeX){
    closeXEl.parentNode.replaceChild(closeX, closeXEl);
  }

  const colorBtns = Array.from(overlay.querySelectorAll(".verbColorBtn")).map(b=>{
    const c = b.cloneNode(true);
    b.parentNode.replaceChild(c, b);
    return c;
  });

  function closeVerbList(){
    overlay.classList.add("hidden");
    overlay.classList.remove("flex");
  }

  if(closeBtn) closeBtn.addEventListener("click", closeVerbList);
  if(closeX) closeX.addEventListener("click", closeVerbList);
  overlay.onclick = (ev)=>{ if(ev.target===overlay) closeVerbList(); }; 

  colorBtns.forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const key = btn.dataset.filter;
      if(!key) return;

      if(selected.has(key)){
        selected.delete(key);
      } else {
        selected.add(key);
        if(selected.size===3){
          selected.clear(); // all three => reset to "all"
        }
      }

      // Visual state
      colorBtns.forEach(b=>{
        b.classList.toggle("ring-2", selected.has(b.dataset.filter));
        b.classList.toggle("ring-slate-400", selected.has(b.dataset.filter));
      });

      applyFilters();
    });
  });

  qEl.addEventListener("input", ()=>{
    term = norm(qEl.value);
    applyFilters();
  });

  // Open modal
  overlay.classList.remove("hidden");
  overlay.classList.add("flex");
  applyFilters();
  qEl.focus();
}


els.btnList.addEventListener("click", openVerbList);


els.btnStats.addEventListener("click", ()=>{
  openStats();
});

function openStats(){
  renderStats();
  enableStatsDrag();
  const m = document.getElementById("statsModal");
  if(m){ m.classList.remove("hidden"); m.classList.add("flex"); }
}
function closeStats(){
  const m = document.getElementById("statsModal");
  if(m){ m.classList.add("hidden"); m.classList.remove("flex"); }
}

function setStatsTab(tab){
  document.querySelectorAll(".statsTabPanel").forEach(p=>{
    p.classList.toggle("hidden", p.id !== "statsTab_"+tab);
  });
  document.querySelectorAll(".statsTabBtn").forEach(b=>{
    const active = (b.dataset.tab===tab);
    b.classList.toggle("bg-slate-900", active);
    b.classList.toggle("text-white", active);
    b.classList.toggle("bg-slate-200", !active);
    b.classList.toggle("text-slate-800", !active);
  });
}


let _statsDragReady = false;
function enableStatsDrag(){
  if(_statsDragReady) return;
  // Only for desktop-like pointers (mouse/trackpad)
  if(!window.matchMedia || !window.matchMedia("(pointer:fine)").matches) return;

  const overlay = document.getElementById("statsModal");
  const card = document.getElementById("statsCard");
  const header = document.getElementById("statsHeader");
  if(!overlay || !card || !header) return;

  _statsDragReady = true;
  header.style.cursor = "move";

  // Make the card draggable by positioning it absolutely inside the overlay
  card.style.position = "absolute";
  card.style.left = "50%";
  card.style.top = "50%";
  card.style.transform = "translate(-50%, -50%)";

  let dragging = false;
  let startX=0, startY=0, startLeft=0, startTop=0;

  const onDown = (ev)=>{
    // Ignore clicks on buttons in header (close X etc.)
    if(ev.target.closest("button")) return;
    dragging = true;
    const rect = card.getBoundingClientRect();
    startX = ev.clientX;
    startY = ev.clientY;
    startLeft = rect.left;
    startTop = rect.top;
    ev.preventDefault();
  };

  const clamp = (v, min, max)=>Math.min(max, Math.max(min, v));

  const onMove = (ev)=>{
    if(!dragging) return;
    const dx = ev.clientX - startX;
    const dy = ev.clientY - startY;

    // convert viewport px to left/top within overlay
    const newLeft = startLeft + dx;
    const newTop = startTop + dy;

    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const rect = card.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    const clLeft = clamp(newLeft, 8, vw - w - 8);
    const clTop  = clamp(newTop, 8, vh - h - 8);

    card.style.left = clLeft + "px";
    card.style.top = clTop + "px";
    card.style.transform = "translate(0,0)";
  };

  const onUp = ()=>{
    dragging = false;
  };

  header.addEventListener("mousedown", onDown);
  window.addEventListener("mousemove", onMove);
  window.addEventListener("mouseup", onUp);

  // Reset to centered when closing, so it doesn't drift forever
  const resetPos = ()=>{
    card.style.left = "50%";
    card.style.top = "50%";
    card.style.transform = "translate(-50%, -50%)";
  };
  const closeX = document.getElementById("statsCloseX");
  const closeBtn = document.getElementById("statsCloseBtn");
  if(closeX) closeX.addEventListener("click", resetPos);
  if(closeBtn) closeBtn.addEventListener("click", resetPos);
}

function renderStats(){
  // summary totals across levels
  const total = {correct:0, wrong:0, mastered:0, rounds:0};
  for(const lvl of [1,2,3,4,5,6]){
    total.correct += (state.progress[lvl]?.correct||0);
    total.wrong   += (state.progress[lvl]?.wrong||0);
    total.mastered += Object.keys(state.progress[lvl]?.mastered||{}).length;
    total.rounds += getRounds(lvl);
  }

  const tabSum = document.getElementById("statsTab_summary");
  const tabLvl = document.getElementById("statsTab_levels");
  const tabDiff = document.getElementById("statsTab_difficult");
  const tabRounds = document.getElementById("statsTab_rounds");

  if(tabSum){ tabSum.innerHTML = ""; }

  if(tabLvl){
    const H = UI[getLang()].statsLevelsHead;
    const total = allInfs().length;
    const rows = [1,2,3,4,5,6].map(lvl=>{
      const dom = dominatedStarsStats(lvl);
      const correct = state.progress[lvl]?.correct||0;
      const wrong = state.progress[lvl]?.wrong||0;
      const rounds = getRounds(lvl);
      const pctDom = dom.total>0 ? Math.round(100*dom.unstarred/dom.total) : 0;
      return `<tr class="border-t">
        <td class="py-2 font-bold">N${lvl}</td>
        <td class="py-2">${dom.unstarred} / ${dom.total}</td>
        <td class="py-2">${pctDom}%</td>
        <td class="py-2">${correct}</td>
        <td class="py-2">${wrong}</td>
        <td class="py-2">${rounds}</td>
      </tr>`;
    }).join("");
    tabLvl.innerHTML = `
      <div class="overflow-x-auto">
        <table class="w-full text-sm">
          <thead><tr class="text-left text-slate-500">
            <th class="py-2">${H.level}</th><th>${H.mastered}</th><th>${H.pct}</th><th>${H.correct}</th><th>${H.wrong}</th><th>${H.rounds}</th>
          </tr></thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
    `;
  }

  if(tabDiff){
    // collect top difficult keys across levels (by errors)
    const items = [];
    for(const lvl of [1,2,3,4,5,6]){
      const map = (aggregateErrMap()[lvl]) || {};
      for(const k of Object.keys(map)){
        items.push({lvl, key:k, n: map[k]});
      }
    }
    items.sort((a,b)=>b.n-a.n);
    const top = items.slice(0,20);
    if(top.length===0){
      tabDiff.innerHTML = `<p class="text-sm text-slate-600">${UI[getLang()].statsDiffEmpty}</p>`;
    }else{
      const li = top.map(it=>{
        const v = getVerbByKey(it.key);
        const shown = v ? (v.inf||"") : it.key;
        return `<li class="flex justify-between gap-3 border rounded-lg p-2">
          <div><span class="font-bold">N${it.lvl}</span> Â· <span class="font-mono">${escapeHtml(shown)}</span></div>
          <div class="text-slate-600">${it.n} ${UI[getLang()].statsDiffErrors}</div>
        </li>`;
      }).join("");
      tabDiff.innerHTML = `<ul class="space-y-2">${li}</ul>`;
    }
  }

  if(tabRounds){
    const RH = UI[getLang()].statsRoundsHead;
    const rows = [1,2,3,4,5,6].map(lvl=>{
      const r = getRounds(lvl);

      // current round (since last reset)
      const c = state.progress[lvl]?.correct||0;
      const w = state.progress[lvl]?.wrong||0;
      const accRound = (c+w)>0 ? Math.round(100*c/(c+w)) : 0;

      // totals (history + current)
      const hist = getHistory(lvl);
      const totC = hist.reduce((s,x)=>s+(x.correct||0),0) + c;
      const totW = hist.reduce((s,x)=>s+(x.wrong||0),0) + w;
      const accTotal = (totC+totW)>0 ? Math.round(100*totC/(totC+totW)) : 0;

      const delta = (totC+totW)>0 ? (accRound - accTotal) : 0;
      const deltaTxt = (totC+totW)>0 ? `${delta>=0?"+":""}${delta}%` : "â€”";

      return `<tr class="border-t">
        <td class="py-2 font-bold">N${lvl}</td>
        <td class="py-2">${r}</td>
        <td class="py-2">${accRound}%</td>
        <td class="py-2 text-slate-600">${accTotal}%</td>
        <td class="py-2">${deltaTxt}</td>
      </tr>`;
    }).join("");

    tabRounds.innerHTML = `
      <div class="overflow-x-auto">
        <table class="w-full text-sm">
          <thead><tr class="text-left text-slate-500">
            <th class="py-2">${RH.level}</th><th>${RH.round}</th><th>${RH.accRound}</th><th>${RH.accTotal}</th><th>${RH.delta}</th>
          </tr></thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
      <p class="mt-3 text-xs text-slate-500">${UI[getLang()].statsRoundsNote}</p>
    `;
  }

  // wire tabs/close (once)
  const closeX = document.getElementById("statsCloseX");
  const closeBtn = document.getElementById("statsCloseBtn");
  if(closeX) closeX.onclick = closeStats;
  if(closeBtn) closeBtn.onclick = closeStats;

  document.querySelectorAll(".statsTabBtn").forEach(b=>{
    b.onclick = ()=>setStatsTab(b.dataset.tab);
  });
  setStatsTab("levels");
}
els.btnHelp.addEventListener("click", ()=>{ openModal(UI[getLang()].helpTitle, UI[getLang()].helpBody); });
els.btnReset.addEventListener("click", ()=>{
  const lvl = state.currentLevel;

  if(!lvl){
    openModal(UI[getLang()].resetModalTitle, `
      <p>${UI[getLang()].selectLevelToStart}</p>
      <div class="mt-4 flex gap-2 justify-end">
        <button id="modalOkBtn" class="bg-blue-600 text-white font-semibold px-4 py-2 rounded hover:bg-blue-700 transition">${UI[getLang()].ok}</button>
      </div>
    `);
    setTimeout(()=>{
      const b=document.getElementById("modalOkBtn");
      if(b) b.onclick = closeModal;
    },0);
    return;
  }

  openModal(UI[getLang()].resetModalTitle, `
    <p>${UI[getLang()].resetConfirmBody(lvl)}</p>
    <p class="mt-2 text-slate-600">${UI[getLang()].resetWarn}</p>
    <div class="mt-4 flex gap-2 justify-end">
      <button id="cancelReset" class="bg-slate-200 text-slate-800 font-semibold px-4 py-2 rounded-lg hover:bg-slate-300 transition">${UI[getLang()].cancel}</button>
      <button id="confirmReset" class="bg-red-600 text-white font-semibold px-4 py-2 rounded hover:bg-red-700 transition">${UI[getLang()].resetConfirmBtn}</button>
    </div>
  `, { showOk: false });

  setTimeout(()=>{
    const btn=document.getElementById("confirmReset");
    const c=document.getElementById("cancelReset");
    if(c) c.onclick = closeModal;
    if(btn) btn.onclick = ()=>{
      // Reinicia NOMÃ‰S el nivell actual
      // Reinicia NOMÃ‰S el nivell actual (comenÃ§a una nova ronda, perÃ² es guarda lâ€™histÃ²ric per estadÃ­stiques)
      resetRoundStats(lvl);

      state.progress[lvl] = { mastered: {}, correct: 0, wrong: 0 };
      state.retries[lvl] = [];
      state.queue = [];
      state.current = null;
      state.answered = false;
      if(state.qPos) state.qPos[lvl] = 0;
      if(state.levelCompleteShown) state.levelCompleteShown[lvl] = false;
      saveState();
      closeModal();

      // Torna a comenÃ§ar el nivell des de la primera pregunta
      startLevel(lvl);

      updateStatsUI();
    };
  },0);
});

// Check for English voice on startup
if("speechSynthesis" in window){
  window.speechSynthesis.onvoiceschanged = ()=>{
    if(!hasEnglishVoice()){
      console.warn("No English voice detected");
      // Opcional: mostrar avÃ­s a l'usuari
      setTimeout(()=>{
        const lang = getLang();
        const msgs = {
          ca: "âš ï¸ No s'ha detectat cap veu en anglÃ¨s al teu dispositiu. La pronunciaciÃ³ pot no funcionar correctament. InstalÂ·la una veu anglesa a la configuraciÃ³ del sistema.",
          es: "âš ï¸ No se ha detectado ninguna voz en inglÃ©s en tu dispositivo. La pronunciaciÃ³n puede no funcionar correctamente. Instala una voz inglesa en la configuraciÃ³n del sistema.",
          ka: "âš ï¸ áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒ˜ áƒ®áƒ›áƒ áƒáƒ  áƒáƒ áƒ˜áƒ¡ áƒœáƒáƒáƒáƒ•áƒœáƒ˜. áƒ’áƒáƒ“áƒáƒ“áƒ˜ áƒ¡áƒ˜áƒ¡áƒ¢áƒ”áƒ›áƒ˜áƒ¡ áƒáƒáƒ áƒáƒ›áƒ”áƒ¢áƒ áƒ”áƒ‘áƒ¨áƒ˜ áƒ“áƒ áƒ©áƒáƒ›áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ” áƒ˜áƒœáƒ’áƒšáƒ˜áƒ¡áƒ£áƒ áƒ˜ áƒ®áƒ›áƒ."
        };
        alert(msgs[lang] || msgs.ca);
      }, 2000);
    }
  };
  // Trigger voice loading
  window.speechSynthesis.getVoices();
}

applyFixedSideButtonWidth();
setNoLevelMode(true);

updateStatsUI();
updateLevelButtons();
setNextEnabled(false);
</script>

<script>
(function(){
  function updateNoSpeak(){
    const qc = document.getElementById("questionCenter");
    const speak = document.getElementById("btnSpeak");
    if(!qc) return;
    
    const isMobile = window.matchMedia("(max-width: 640px)").matches;
    if(!isMobile){
      qc.classList.remove("qc-noSpeak");
      return;
    }
    
    // Check current level - levels 1, 4, 5 should ALWAYS show audio button
    const lvl = state && state.currentLevel ? state.currentLevel : 0;
    const shouldShowAudio = (lvl === 1 || lvl === 4 || lvl === 5);
    
    if(shouldShowAudio){
      qc.classList.remove("qc-noSpeak");
      return;
    }
    
    // For other levels, check if button is actually hidden
    const cs = speak ? window.getComputedStyle(speak) : null;
    const noSpeak = (!speak) ||
      speak.classList.contains("hidden") ||
      speak.hasAttribute("hidden") ||
      (cs && (cs.display === "none" || cs.visibility === "hidden" || cs.opacity === "0")) ||
      (speak && speak.getClientRects().length === 0);
    qc.classList.toggle("qc-noSpeak", noSpeak);
  }
  


function applyMobileLevel6Labels(){
  const isMobile = window.matchMedia && window.matchMedia("(max-width: 640px)").matches;
  const labels = document.querySelectorAll('#level6Area .grid > div > div.text-xs');
  if(labels.length < 3) return;
  if(isMobile){
    labels[0].textContent = "Inf.";
    labels[1].textContent = "Past";
    labels[2].textContent = "PP";
  }else{
    labels[0].textContent = "Infinitive";
    labels[1].textContent = "Simple past";
    labels[2].textContent = "Past participle";
  }
}
window.addEventListener("resize", applyMobileLevel6Labels);

window.addEventListener("load", updateNoSpeak);
  window.addEventListener("resize", updateNoSpeak);
  const speak = document.getElementById("btnSpeak");
  if(speak){
    new MutationObserver(updateNoSpeak).observe(speak, {attributes:true, attributeFilter:["class","style"]});
  }
  // Also update when level changes
  if(window.MutationObserver){
    const bodyObs = new MutationObserver(updateNoSpeak);
    bodyObs.observe(document.body, {attributes:true, attributeFilter:["class"]});
  }
})();
</script>

</body>
</html>
